<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Beam Calculator</title>
  <style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      margin: 0;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      min-height: 100vh;
    }
    .container {
      max-width: 1100px;
      margin: 40px auto;
      background: #fff;
      padding: 32px 32px 24px 32px;
      border-radius: 18px;
      box-shadow: 0 6px 32px rgba(60, 72, 88, 0.12), 0 1.5px 6px rgba(60, 72, 88, 0.08);
    }
    h1, h2 {
      text-align: center;
      color: #2d3a4a;
      margin-bottom: 18px;
      letter-spacing: 1px;
    }    
    h1 {
      font-size: 2.2rem;
      font-weight: 700;
      margin-top: 0;
    }    
    h2 {
      font-size: 1.3rem;
      font-weight: 600;
      margin-top: 18px;
    }    
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 28px;
      margin-bottom: 18px;
    }    
    .col {
      flex: 1 1 0;
      min-width: 240px;
      background: #f7fafd;
      border-radius: 12px;
      padding: 18px 16px 12px 16px;
      box-shadow: 0 1px 4px rgba(60, 72, 88, 0.06);
    }    
    label {
      font-weight: 500;
      color: #3a4656;
      display: block;
      margin-bottom: 6px;
      letter-spacing: 0.2px;
    }    
    input[type="number"], select {
      width: 70%;
      padding: 8px 10px;
      margin: 4px 0 12px 0;
      border: 1px solid #d1d5db;
      border-radius: 7px;
      background: #f8fafb;
      font-size: 1rem;
      transition: border 0.2s;
    }    
    input[type="number"]:focus, select:focus {
      border: 1.5px solid #6abf69;
      outline: none;
      background: #f4fff4;
    }    
    button, .addLoadBtn {
      background: linear-gradient(90deg, #6abf69 0%, #4e9e5d 100%);
      color: #fff;
      padding: 10px 22px;
      border: none;
      border-radius: 7px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      margin-top: 8px;
      box-shadow: 0 2px 8px rgba(60, 72, 88, 0.08);
      transition: background 0.2s, box-shadow 0.2s;
    }    
    button:hover, .addLoadBtn:hover {
      background: linear-gradient(90deg, #4e9e5d 0%, #6abf69 100%);
      box-shadow: 0 4px 16px rgba(60, 72, 88, 0.13);
    }    
    .addLoadBtn {
      margin-left: 0;
      margin-top: 0;
      padding: 7px 16px;
      font-size: 0.97rem;
    }    
    .removeBtn, .removeLoadBtn {
      background: #e74c3c;
      color: #fff;
      margin-left: 16px;
      padding: 7px 14px;
      border-radius: 7px;
      font-size: 0.97rem;
      border: none;
      cursor: pointer;
      transition: background 0.2s;
    }    
    .removeBtn:hover, .removeLoadBtn:hover {
      background: #c0392b;
    }    
    details {
      margin-bottom: 18px;
      background: #f3f6fa;
      border-radius: 10px;
      box-shadow: 0 1px 4px rgba(60, 72, 88, 0.06);
      padding: 10px 14px 8px 14px;
    }    
    details[open] summary {
      font-weight: 600;
      color: #2d3a4a;
    }    
    summary {
      font-size: 1.08rem;
      cursor: pointer;
      outline: none;
      margin-bottom: 8px;
    }    
    #resultArea {
      position: relative;
      min-height: 60px;
      margin-top: 30px;
      background: #f7fafd;
      border-radius: 12px;
      box-shadow: 0 1px 4px rgba(60, 72, 88, 0.06);
      padding: 18px 18px 10px 18px;
    }    
    #resultsContent {
      font-size: 1.08rem;
      color: #2d3a4a;
    }    
    #steelCheckArea {
      margin-top: 18px;
      font-size: 1.05rem;
      color: #2d3a4a;
    }    
    .result {
      background: #e8f0fe;
      padding: 12px;
      border-radius: 8px;
      margin-top: 20px;
    }    
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      background: #f8fafb;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 1px 4px rgba(60, 72, 88, 0.06);
    }    
    th, td {
      border: 1px solid #e0e6ed;
      padding: 8px 6px;
      text-align: center;
      font-size: 1rem;
    }    
    th {
      background: #e3e9f2;
      color: #2d3a4a;
      font-weight: 600;
    }    
    tr:nth-child(even) {
      background: #f4f7fa;
    }    
    canvas {
      display: block;
      margin: 18px auto 10px auto;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 1px 4px rgba(60, 72, 88, 0.07);
    }    
    #downloadBtn {
      display: block !important;
      position: absolute;
      top: 18px;
      right: 18px;
      z-index: 9999;
    }    
    #downloadBtn:hover {
      background: linear-gradient(90deg, #6abf69 0%, #3a4656 100%);
    }    
    input[type="radio"] {
      accent-color: #6abf69;
      margin-right: 4px;
    }    
    input[type="radio"]:focus {
      outline: 2px solid #6abf69;
    }    
    ::-webkit-input-placeholder { color: #b0b8c1; }
    ::-moz-placeholder { color: #b0b8c1; }
    :-ms-input-placeholder { color: #b0b8c1; }
    ::placeholder { color: #b0b8c1; }    
    @media (max-width: 900px) {
      .row {
        flex-direction: column;
        gap: 0;
      }
      .col {
        min-width: 100%;
        margin-bottom: 18px;
      }
      .container {
        padding: 12px 4px 12px 4px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Beam Calculator</h1>
    <form id="beamForm" onsubmit="return false;">
      <!-- 3-column input section -->
      <div class="row">
        <div class="col">
          <h2>Beam Properties</h2>
          <label>Support condition: <select id="supportCondition"><option value="simply">Simply Supported</option><option value="continuous">Continuous</option><option value="cantilever">Cantilever</option></select></label><br>
          <label>Beam Type: <select id="beamType"><option value="rbeam">R-Beam</option><option value="tbeam">T-Beam</option><option value="lbeam">L-Beam</option></select></label><br>
          <label>Beam Depth (h) (mm): <input type="number" id="beamDepth" value="600"></label><br>
          <label>Beam Width (b) (mm): <input type="number" id="beamWidth" value="300"></label><br>
          <label id="beffLabel" style="display:none;">Effective Flange Width (beff) (mm): <input type="number" id="beffInput" value="600"></label>
          <label id="flangeDepthLabel" style="display:none;">Flange Depth (hf) (mm): <input type="number" id="flangeDepth" value="100"></label>
        </div>
        <div class="col">
          <h2>Beam Properties</h2>
          <label>Diameter of Bar (mm): <input type="number" id="barDiameter" value="20"></label><br>
          <label>Diameter of Link (mm): <input type="number" id="linkDiameter" value="8"></label><br>
          <label>Concrete Cover (mm): <input type="number" id="concreteCover" value="25"></label><br>
          <label>f<sub>ck</sub> (N/mm²): <input type="number" id="fck" value="25"></label><br>
          <label>f<sub>yk</sub> (N/mm²): <input type="number" id="fyk" value="500"></label>
          <label>Concrete Density (kN/m³): <input type="number" id="concreteDensity" value="25"></label>
        </div>
        <div class="col">
          <h2>Column Properties</h2>
          <label>Column Height (mm): <input type="number" id="colHeight" value="3000"></label><br>
          <label>Column Width (mm): <input type="number" id="colWidth" value="300"></label><br>
          <label>Column Breadth (mm): <input type="number" id="colBreadth" value="300"></label><br>
          <label>Modulus E (GPa): <input type="number" id="modulusE" value="25"></label><br>
          <div style="display: flex; gap: 20px; margin-top: 10px;">
            <div style="flex:1;">
              <strong>Beam Stiffness</strong><br><br>
              I = <span id="beamI">-</span> m<sup>4</sup><br>
              EI = <span id="beamEI">-</span> N·m<sup>2</sup>
            </div>
            <div style="flex:1;">
              <strong>Column Stiffness</strong><br><br>
              I = <span id="colI">-</span> m<sup>4</sup><br>
              EI = <span id="colEI">-</span> N·m<sup>2</sup>
            </div>
          </div>
        </div>
      <div>
          <!-- Span 1 Details -->
          <details open>
            <summary>Span 1 Details</summary>
            <div style="display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 10px; align-items: center;">
              <label style="display: flex; justify-content: space-between; align-items: center; width: 320px;">
                Span Length (mm): <input type="number" id="spanLength" value="1000" style="width: 55%;">
              </label>
              <div id="loadTypeRadios" style="display: flex; align-items: center; gap: 10px;">
                <label style="font-weight:normal;"><input type="radio" name="loadType" value="udl" checked> UDL (kN/m)</label>
                <label style="font-weight:normal;"><input type="radio" name="loadType" value="point"> Point Load (kN)</label>
                <label style="font-weight:normal;"><input type="radio" name="loadType" value="moment"> Moment (kNm)</label>
              </div>
              <label style="display: flex; justify-content: space-between; align-items: center; width: 320px;">
                Load Magnitude: <input type="number" id="UltimateLoad" value="10" style="width: 55%;">
              </label>
              <div id="loadPositionContainer">
                <label id="loadPositionLabel" style="display: flex; justify-content: space-between; align-items: center; width: 320px;">
                  Load Position (mm, for point/moment): <input type="number" id="loadPosition" value="2" style="width: 55%;">
                </label>
              </div>
            </div>
            <div class="loadsContainer"></div>
            <button type="button" class="addLoadBtn">+ Add Load</button>
          </details>
          <!-- Spans Sections -->
          <div id="spansContainer">
            <!-- Span sections will be added here -->
          </div>
          <button id="addSpanBtn" type="button">+ Add Span</button>

          <div style="text-align:center;">
            <canvas id="beamCanvas" width="600" height="300" style="border:1px solid #ccc; margin-bottom:20px;"></canvas>
          </div>

          <button type="button" onclick="calculate()">Calculate</button>

          <h2>Steel Bar Table (Ref)</h2>
          <table>
            <thead>
              <tr>
                <th>Bar Size (mm)</th>
                <th colspan="10">Number of Bars</th>
              </tr>
              <tr>
                <th></th>
                <th>1</th><th>2</th><th>3</th><th>4</th><th>5</th>
                <th>6</th><th>7</th><th>8</th><th>9</th><th>10</th>
              </tr>
            </thead>
            <tbody>
              <tr><td>6</td><td>28.3</td><td>56.6</td><td>84.9</td><td>113</td><td>142</td><td>170</td><td>198</td><td>226</td><td>255</td><td>283</td></tr>
              <tr><td>8</td><td>50.3</td><td>101</td><td>151</td><td>201</td><td>252</td><td>302</td><td>352</td><td>402</td><td>453</td><td>503</td></tr>
              <tr><td>10</td><td>78.5</td><td>157</td><td>236</td><td>314</td><td>393</td><td>471</td><td>550</td><td>628</td><td>707</td><td>785</td></tr>
              <tr><td>12</td><td>113</td><td>226</td><td>339</td><td>452</td><td>566</td><td>679</td><td>792</td><td>905</td><td>1020</td><td>1130</td></tr>
              <tr><td>16</td><td>201</td><td>402</td><td>603</td><td>804</td><td>1010</td><td>1210</td><td>1410</td><td>1610</td><td>1810</td><td>2010</td></tr>
              <tr><td>20</td><td>314</td><td>628</td><td>943</td><td>1260</td><td>1570</td><td>1890</td><td>2200</td><td>2510</td><td>2830</td><td>3140</td></tr>
              <tr><td>25</td><td>491</td><td>982</td><td>1470</td><td>1960</td><td>2450</td><td>2950</td><td>3440</td><td>3930</td><td>4420</td><td>4910</td></tr>
              <tr><td>32</td><td>804</td><td>1610</td><td>2410</td><td>3220</td><td>4020</td><td>4830</td><td>5630</td><td>6430</td><td>7240</td><td>8040</td></tr>
              <tr><td>40</td><td>1260</td><td>2510</td><td>3770</td><td>5030</td><td>6280</td><td>7540</td><td>8800</td><td>10100</td><td>11300</td><td>12600</td></tr>
            </tbody>
          </table>      
         
        </div>
      </div>
      </form>

      <div id="resultArea" style="position: relative;">
        <div id="resultsContent">
          <!-- Main calculation results go here -->
          <!-- Steel check and diagrams will be injected below -->
          <div id="steelCheckArea"></div>
        </div>
        <button id="downloadBtn" onclick="downloadPDF()" style="position: absolute; top: 10px; right: 10px; display: none;">
          Download
        </button>
      </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
  <script>
    document.getElementById('beamForm').addEventListener('submit', function(e) {
      e.preventDefault();
    });
    // --- Utility Functions ---
    function getInputValue(id, fallback = 0) {
      const el = document.getElementById(id);
      return el ? parseFloat(el.value) || fallback : fallback;
    }

    function getSelectedRadio(name) {
      const radio = document.querySelector(`input[name="${name}"]:checked`);
      return radio ? radio.value : null;
    }

    // --- Flange Inputs Show/Hide ---
    window.addEventListener('DOMContentLoaded', function() {
      function toggleFlangeInputs() {
        const type = document.getElementById('beamType').value;
        document.getElementById('beffLabel').style.display = (type === 'tbeam' || type === 'lbeam') ? '' : 'none';
        document.getElementById('flangeDepthLabel').style.display = (type === 'tbeam' || type === 'lbeam') ? '' : 'none';
      }
      document.getElementById('beamType').addEventListener('change', toggleFlangeInputs);
      toggleFlangeInputs();
    });

    // --- UI Event Handlers ---
    document.getElementById('supportCondition').addEventListener('change', function() {
      const val = this.value;
      document.getElementById('spansContainer').style.display = (val === 'continuous') ? '' : 'none';
      document.getElementById('addSpanBtn').style.display = (val === 'continuous') ? '' : 'none';
      document.getElementById('beamDiagrams').style.display = (val === 'simply') ? '' : 'none';
    });
    
    function computeStiffness() {
      // Beam
      const beamWidth = parseFloat(document.getElementById('beamWidth').value) / 1000; // mm to m
      const beamDepth = parseFloat(document.getElementById('beamDepth').value) / 1000; // mm to m
      const E = parseFloat(document.getElementById('modulusE').value) * 1e9; // GPa to Pa
      const I_beam = (beamWidth * Math.pow(beamDepth, 3)) / 12;
      const EI_beam = E * I_beam;
      document.getElementById('beamI').textContent = isFinite(I_beam) ? I_beam.toExponential(3) : '-';
      document.getElementById('beamEI').textContent = isFinite(EI_beam) ? EI_beam.toExponential(3) : '-';

      // Column
      const colWidth = parseFloat(document.getElementById('colWidth').value) / 1000; // mm to m
      const colBreadth = parseFloat(document.getElementById('colBreadth').value) / 1000; // mm to m
      const I_col = (colWidth * Math.pow(colBreadth, 3)) / 12;
      const EI_col = E * I_col;
      document.getElementById('colI').textContent = isFinite(I_col) ? I_col.toExponential(3) : '-';
      document.getElementById('colEI').textContent = isFinite(EI_col) ? EI_col.toExponential(3) : '-';
    }
    ["beamWidth", "beamDepth", "modulusE", "colWidth", "colBreadth"].forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.addEventListener('input', computeStiffness);
      }
    });
    computeStiffness();
    
    // --- Span Management ---
    let spanCount = 1;
    document.getElementById('addSpanBtn').addEventListener('click', addSpan);
    
    function addSpan() {
      spanCount++;
      const container = document.getElementById('spansContainer');
      const details = document.createElement('details');
      details.open = true;
      const summary = document.createElement('summary');
      summary.textContent = `Span ${spanCount} Details`;
    
      // Remove button
      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.textContent = 'Remove';
      removeBtn.style.marginLeft = '20px';
      removeBtn.style.background = '#c0392b';
      removeBtn.style.color = '#fff';
      removeBtn.style.border = 'none';
      removeBtn.style.borderRadius = '5px';
      removeBtn.style.padding = '5px 12px';
      removeBtn.style.cursor = 'pointer';
      removeBtn.onclick = function () {
        details.remove();
        renumberSpans();
        drawFBDAllSpans();
      };
      summary.appendChild(removeBtn);
      details.appendChild(summary);
    
      // Fields
      const spanDiv = document.createElement('div');
      spanDiv.className = "span-fields";
      spanDiv.style.display = "flex";
      spanDiv.style.flexWrap = "wrap";
      spanDiv.style.gap = "20px";
      spanDiv.style.marginBottom = "10px";
      spanDiv.style.alignItems = "center";
      
    
      // Span Length
      const spanLengthLabel = document.createElement('label');
      spanLengthLabel.style.display = "flex";
      spanLengthLabel.style.justifyContent = "space-between";
      spanLengthLabel.style.alignItems = "center";
      spanLengthLabel.style.width = "320px";
      spanLengthLabel.innerHTML = `Span Length (mm): <input type="number" value="1000" style="width: 55%;">`;
      spanDiv.appendChild(spanLengthLabel);
    
      // Load Type radios
      const loadTypeDiv = document.createElement('div');
      loadTypeDiv.style.display = "flex";
      loadTypeDiv.style.alignItems = "center";
      loadTypeDiv.style.gap = "10px";
      loadTypeDiv.innerHTML = `
        <label style="font-weight:normal;"><input type="radio" name="loadType${spanCount}" value="udl" checked> UDL (kN/m)</label>
        <label style="font-weight:normal;"><input type="radio" name="loadType${spanCount}" value="point"> Point Load (kN)</label>
        <label style="font-weight:normal;"><input type="radio" name="loadType${spanCount}" value="moment"> Moment (kNm)</label>
      `;
      spanDiv.appendChild(loadTypeDiv);
    
      // Load Magnitude
      const loadMagLabel = document.createElement('label');
      loadMagLabel.style.display = "flex";
      loadMagLabel.style.justifyContent = "space-between";
      loadMagLabel.style.alignItems = "center";
      loadMagLabel.style.width = "320px";
      loadMagLabel.innerHTML = `Load Magnitude: <input type="number" value="10" style="width: 55%;">`;
      spanDiv.appendChild(loadMagLabel);
    
      // Load Position
      const loadPosLabel = document.createElement('label');
      loadPosLabel.style.display = "flex";
      loadPosLabel.style.justifyContent = "space-between";
      loadPosLabel.style.alignItems = "center";
      loadPosLabel.style.width = "320px";
      loadPosLabel.innerHTML = `Load Position (mm, for point/moment): <input type="number" value="2" style="width: 55%;">`;
      spanDiv.appendChild(loadPosLabel);
    
      // Loads container and Add Load button
      const loadsContainer = document.createElement('div');
      loadsContainer.className = 'loadsContainer';
      spanDiv.appendChild(loadsContainer);
    
      const addLoadBtn = document.createElement('button');
      addLoadBtn.type = 'button';
      addLoadBtn.textContent = '+ Add Load';
      addLoadBtn.className = 'addLoadBtn';
      addLoadBtn.style.marginLeft = '10px';
      spanDiv.appendChild(addLoadBtn);
    
      // Add event listener for Add Load button
      addLoadBtn.addEventListener('click', function(e) {
        e.preventDefault();
        addDynamicLoad(loadsContainer, spanCount, details);
      });
    
      details.appendChild(spanDiv);
      container.appendChild(details);

      // After details.appendChild(spanDiv);
      spanDiv.querySelectorAll('input,select').forEach(input => {
        input.addEventListener('input', drawFBDAllSpans);
        input.addEventListener('change', drawFBDAllSpans);
      });
    

      renumberSpans();
      drawFBDAllSpans();
    }

    function renumberSpans() {
      const container = document.getElementById('spansContainer');
      const spans = container.querySelectorAll('details');
      spans.forEach((details, idx) => {
        const summary = details.querySelector('summary');
        if (summary) {
          summary.childNodes[0].textContent = `Span ${idx + 2} Details`; // +2 because Span 1 is static
        }
      });
    }

    // --- Load Management---
    function addDynamicLoad(loadsContainer, spanNum, details) {
      const loadDiv = document.createElement('div');
      loadDiv.style.display = "flex";
      loadDiv.style.flexWrap = "wrap";
      loadDiv.style.gap = "20px";
      loadDiv.style.marginBottom = "10px";
      loadDiv.style.alignItems = "center";
    
      // Load Type radios
      const loadTypeDiv = document.createElement('div');
      loadTypeDiv.style.display = "flex";
      loadTypeDiv.style.alignItems = "center";
      loadTypeDiv.style.gap = "10px";
      loadTypeDiv.innerHTML = `
        <label style="font-weight:normal;"><input type="radio" name="loadTypeExtra${Date.now()}" value="udl" checked> UDL (kN/m)</label>
        <label style="font-weight:normal;"><input type="radio" name="loadTypeExtra${Date.now()}" value="point"> Point Load (kN)</label>
        <label style="font-weight:normal;"><input type="radio" name="loadTypeExtra${Date.now()}" value="moment"> Moment (kNm)</label>
      `;
      loadDiv.appendChild(loadTypeDiv);
    
      // Load Magnitude
      const loadMagLabel = document.createElement('label');
      loadMagLabel.style.display = "flex";
      loadMagLabel.style.justifyContent = "space-between";
      loadMagLabel.style.alignItems = "center";
      loadMagLabel.style.width = "220px";
      loadMagLabel.innerHTML = `Load Magnitude: <input type="number" value="10" style="width: 55%;">`;
      loadDiv.appendChild(loadMagLabel);
      
      // Load Position (dynamic)
      const loadPosContainer = document.createElement('div');
      loadPosContainer.className = 'loadPosContainer';
      function updateLoadPosUI() {
        // Find the span length for this span
        let spanLength = 1000;
        // Try to get the closest span length input in the parent .span-fields
        let parentSpan = loadDiv.closest('.span-fields');
        if (parentSpan) {
          const spanInput = parentSpan.querySelector('label input[type="number"]');
          if (spanInput) spanLength = parseFloat(spanInput.value) || 1000;
        }
        const type = loadDiv.querySelector('input[type="radio"]:checked').value;
        if (type === "udl") {
          loadPosContainer.innerHTML = `
            <label style="display: flex; justify-content: space-between; align-items: center; width: 220px;">
              Where is it acting (mm): 
              <span style="display:flex;gap:5px;align-items:center;">
                from <input type="number" class="udlFrom" value="0" min="0" max="${spanLength}" style="width:60px;">
                to <input type="number" class="udlTo" value="${spanLength}" min="0" max="${spanLength}" style="width:60px;">
              </span>
            </label>
          `;
          // Safeguards
          const fromInput = loadPosContainer.querySelector('.udlFrom');
          const toInput = loadPosContainer.querySelector('.udlTo');
          fromInput.addEventListener('input', () => {
            if (parseFloat(fromInput.value) < 0) fromInput.value = 0;
            if (parseFloat(fromInput.value) > spanLength) fromInput.value = spanLength;
            if (parseFloat(fromInput.value) > parseFloat(toInput.value)) fromInput.value = toInput.value;
            drawFBDAllSpans();
          });
          toInput.addEventListener('input', () => {
            if (parseFloat(toInput.value) < 0) toInput.value = 0;
            if (parseFloat(toInput.value) > spanLength) toInput.value = spanLength;
            if (parseFloat(toInput.value) < parseFloat(fromInput.value)) toInput.value = fromInput.value;
            drawFBDAllSpans();
          });
        } else {
          loadPosContainer.innerHTML = `
            <label style="display: flex; justify-content: space-between; align-items: center; width: 220px;">
              Load Position (mm, for point/moment): <input type="number" class="loadPosition" value="2" style="width: 60px;">
            </label>
          `;
          loadPosContainer.querySelector('.loadPosition').addEventListener('input', drawFBDAllSpans);
        }
      }
      loadDiv.appendChild(loadPosContainer);
      updateLoadPosUI();
      
      // Listen for load type change
      loadTypeDiv.querySelectorAll('input[type="radio"]').forEach(radio => {
        radio.addEventListener('change', updateLoadPosUI);
      });
    
      // Remove button for this load
      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.textContent = 'Remove Load';
      removeBtn.style.marginLeft = '20px';
      removeBtn.style.background = '#c0392b';
      removeBtn.style.color = '#fff';
      removeBtn.style.border = 'none';
      removeBtn.style.borderRadius = '5px';
      removeBtn.style.padding = '5px 12px';
      removeBtn.style.cursor = 'pointer';
      removeBtn.onclick = function () {
        loadDiv.remove();
        drawFBDAllSpans();
      };
    
    // Add listeners to update FBD when any input in this loadDiv changes
    loadDiv.querySelectorAll('input').forEach(input => {
      input.addEventListener('input', drawFBDAllSpans);
      input.addEventListener('change', drawFBDAllSpans);
    });
    loadsContainer.appendChild(loadDiv);

    // Attach listeners to all inputs in this loadDiv
    loadDiv.querySelectorAll('input,select').forEach(input => {
      input.addEventListener('input', drawFBDAllSpans);
      input.addEventListener('change', drawFBDAllSpans);
    });
    }

    //---Diagram Drawing---
    function drawFBDAllSpans(canvasId = 'beamCanvas') {
      const canvas = document.getElementById(canvasId);
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Gather all spans (including Span 1 and dynamic spans)
      let spans = [];

      // For Span 1
      const span1Length = parseFloat(document.getElementById('spanLength').value) || 1000;
      let span1Loads = [];
      
      // Always include the main load
      const span1LoadType = document.querySelector('input[name="loadType"]:checked').value;
      const span1LoadMag = parseFloat(document.getElementById('UltimateLoad').value) || 0;
      if (span1LoadType === "udl") {
        const udlFrom = parseFloat(document.getElementById('udlFrom')?.value) || 0;
        const udlTo = parseFloat(document.getElementById('udlTo')?.value) || (parseFloat(document.getElementById('spanLength').value) || 1000);
        if (span1LoadMag > 0 && udlTo > udlFrom) {
          span1Loads.push({ type: "udl", mag: span1LoadMag, from: udlFrom, to: udlTo });
        }
      } else {
        const span1LoadPos = parseFloat(document.getElementById('loadPosition')?.value) || 0;
        if (span1LoadMag > 0) {
          span1Loads.push({ type: span1LoadType, mag: span1LoadMag, pos: span1LoadPos });
        }
      }
      
      // Also include any extra loads
      const span1LoadsContainer = document.querySelector('details .loadsContainer');
      if (span1LoadsContainer && span1LoadsContainer.children.length > 0) {
        Array.from(span1LoadsContainer.children).forEach(loadDiv => {
          const type = loadDiv.querySelector('input[type="radio"]:checked')?.value;
          let mag = 0, pos = 0;
          loadDiv.querySelectorAll('label').forEach(label => {
            if (label.textContent.trim().startsWith('Load Magnitude')) {
              mag = parseFloat(label.querySelector('input').value) || 0;
            }
          });
          if (type === "udl") {
            const from = parseFloat(loadDiv.querySelector('.udlFrom')?.value) || 0;
            const to = parseFloat(loadDiv.querySelector('.udlTo')?.value) || 0;
            if (mag > 0 && to > from) {
              span1Loads.push({ type, mag, from, to }); // <-- FIXED
            }
          } else {
            const pos = parseFloat(loadDiv.querySelector('.loadPosition')?.value) || 0;
            if (type && mag > 0) {
              span1Loads.push({ type, mag, pos }); // <-- FIXED
            }
          }
        });
      }
      
      spans.push({ length: span1Length, loads: span1Loads });
      
      // For dynamic spans
      document.querySelectorAll('#spansContainer > details').forEach(details => {
        const spanDiv = details.querySelector('.span-fields');
        const length = parseFloat(spanDiv.querySelector('label input[type="number"]').value) || 1000;
        let loads = [];
      
        // Always include the main load for this span
        const mainType = spanDiv.querySelector('input[type="radio"]:checked').value;
        let mainMag = 0, mainPos = 0;
        spanDiv.querySelectorAll('label').forEach(label => {
          if (label.textContent.trim().startsWith('Load Magnitude')) {
            mainMag = parseFloat(label.querySelector('input').value) || 0;
          }
          if (label.textContent.trim().startsWith('Load Position')) {
            mainPos = parseFloat(label.querySelector('input').value) || 0;
          }
        });
        if (mainMag > 0) {
          loads.push({ type: mainType, mag: mainMag, pos: mainPos });
        }
      
        // Include any extra loads for this span
        const loadsContainer = spanDiv.querySelector('.loadsContainer');
        if (loadsContainer && loadsContainer.children.length > 0) {
          Array.from(loadsContainer.children).forEach(loadDiv => {
            const type = loadDiv.querySelector('input[type="radio"]:checked')?.value;
            let mag = 0, pos = 0;
            loadDiv.querySelectorAll('label').forEach(label => {
              if (label.textContent.trim().startsWith('Load Magnitude')) {
                mag = parseFloat(label.querySelector('input').value) || 0;
              }
              if (label.textContent.trim().startsWith('Load Position')) {
                pos = parseFloat(label.querySelector('input').value) || 0;
              }
            });
            if (type && mag > 0) {
              loads.push({ type, mag, pos });
            }
          });
        }
      
        spans.push({ length, loads });
      });

      // Calculate total length
      const totalLength = spans.reduce((sum, s) => sum + s.length, 0);

      // Margins and scaling
      const margin = 40;
      const beamY = 60;
      const beamLengthPx = canvas.width - 2 * margin;
      const scaleX = beamLengthPx / totalLength;

      // Draw all spans as a continuous beam
      let currentX = margin;
      for (let i = 0; i < spans.length; i++) {
        const span = spans[i];
        const spanPx = span.length * scaleX;

        // Draw beam segment
        ctx.strokeStyle = "#222";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(currentX, beamY);
        ctx.lineTo(currentX + spanPx, beamY);
        ctx.stroke();

        // Draw all loads for this span
        span.loads.forEach(loadObj => {
            if (loadObj.type === "udl" && loadObj.mag > 0) {
            ctx.strokeStyle = "blue";
            ctx.fillStyle = "blue";
            // Use from/to for partial UDL, or whole span if not present
            let udlFrom = loadObj.from !== undefined ? loadObj.from : 0;
            let udlTo = loadObj.to !== undefined ? loadObj.to : span.length;
            let udlStartPx = currentX + (udlFrom / span.length) * spanPx;
            let udlEndPx = currentX + (udlTo / span.length) * spanPx;
            let numArrows = Math.max(Math.floor((udlTo - udlFrom) / 500), 2);
            let arrowSpacing = (udlEndPx - udlStartPx) / (numArrows - 1 || 1);
            let udlLineY = beamY - 20;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(udlStartPx, udlLineY);
            ctx.lineTo(udlEndPx, udlLineY);
            ctx.stroke();
            for (let j = 0; j < numArrows; j++) {
              let x = udlStartPx + j * arrowSpacing;
              ctx.beginPath();
              ctx.moveTo(x, udlLineY);
              ctx.lineTo(x, beamY);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(x, beamY);
              ctx.lineTo(x - 3, beamY - 7);
              ctx.lineTo(x + 3, beamY - 7);
              ctx.closePath();
              ctx.fill();
            }
            ctx.font = "12px Arial";
            ctx.fillText(`UDL: ${loadObj.mag} kN/m`, udlStartPx + 10, udlLineY - 10);
          }
          if (loadObj.type === "point" && loadObj.mag > 0) {
            ctx.strokeStyle = "red";
            ctx.fillStyle = "red";
            let posPx = currentX + (loadObj.pos / span.length) * spanPx;
            let pointArrowStart = beamY - 30;
            let pointArrowEnd = beamY;
            ctx.beginPath();
            ctx.moveTo(posPx, pointArrowStart);
            ctx.lineTo(posPx, pointArrowEnd);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(posPx, pointArrowEnd);
            ctx.lineTo(posPx - 7, pointArrowEnd - 10);
            ctx.lineTo(posPx + 7, pointArrowEnd - 10);
            ctx.closePath();
            ctx.fill();
            ctx.font = "12px Arial";
            ctx.fillText(`P = ${loadObj.mag} kN`, posPx - 20, pointArrowStart - 10);
          }
          if (loadObj.type === "moment" && loadObj.mag > 0) {
            ctx.strokeStyle = "purple";
            ctx.beginPath();
            let px = currentX + (loadObj.pos / span.length) * spanPx;
            ctx.arc(px, beamY - 10, 20, Math.PI, 2 * Math.PI, false);
            ctx.stroke();
            ctx.font = "12px Arial";
            ctx.fillStyle = "purple";
            ctx.fillText(`M = ${loadObj.mag} kNm`, px - 20, beamY - 40);
          }
        });

        // Draw span dimension
        ctx.strokeStyle = "#222";
        ctx.fillStyle = "#222";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(currentX, beamY + 30);
        ctx.lineTo(currentX + spanPx, beamY + 30);
        ctx.stroke();
        ctx.font = "12px Arial";
        ctx.fillText(`${(span.length / 1000).toFixed(2)} m`, currentX + spanPx / 2 - 20, beamY + 50);
      
        // Get support condition
        const supportCondition = document.getElementById('supportCondition').value;
        
        // Draw supports at span ends
        if (i === 0) {
          if (supportCondition === "simply") {
            // Pin (triangle)
            ctx.fillStyle = "#444";
            ctx.beginPath();
            ctx.moveTo(currentX, beamY + 2);
            ctx.lineTo(currentX - 15, beamY + 25);
            ctx.lineTo(currentX + 15, beamY + 25);
            ctx.closePath();
            ctx.fill();
          } else if (supportCondition === "continuous" || supportCondition === "cantilever") {
            // Fixed (rectangle)
            ctx.fillStyle = "#444";
            ctx.fillRect(currentX - 10, beamY - 10, 20, 40);
          }
        } else {
          if (supportCondition === "continuous") {
            // Pin (triangle) for intermediate supports
            ctx.fillStyle = "#444";
            ctx.beginPath();
            ctx.moveTo(currentX, beamY + 2);
            ctx.lineTo(currentX - 15, beamY + 25);
            ctx.lineTo(currentX + 15, beamY + 25);
            ctx.closePath();
            ctx.fill();
          }
        }
        
        // Right end support
        if (i === spans.length - 1) {
          if (supportCondition === "simply") {
            // Pin (triangle)
            ctx.fillStyle = "#444";
            ctx.beginPath();
            ctx.moveTo(currentX + spanPx, beamY + 2);
            ctx.lineTo(currentX + spanPx - 15, beamY + 25);
            ctx.lineTo(currentX + spanPx + 15, beamY + 25);
            ctx.closePath();
            ctx.fill();
          } else if (supportCondition === "continuous") {
            // Fixed (rectangle)
            ctx.fillStyle = "#444";
            ctx.fillRect(currentX + spanPx - 10, beamY - 10, 20, 40);
          }
          // For cantilever: do nothing (free end)
        }

        currentX += spanPx;
      }
    }

    function drawBMD(canvasId = 'bmdCanvas') {
      const canvas = document.getElementById(canvasId);
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    
      // Gather spans and support moments
      let spans = [];
      // Span 1
      const span1Length = parseFloat(document.getElementById('spanLength').value) || 1000;
      let span1Loads = [];
      // Main load for Span 1
      const span1LoadType = document.querySelector('input[name="loadType"]:checked').value;
      const span1LoadMag = parseFloat(document.getElementById('UltimateLoad').value) || 0;
      const span1LoadPos = parseFloat(document.getElementById('loadPosition')?.value) || 0;
      if (span1LoadMag > 0) {
        if (span1LoadType === "udl") {
          const udlFrom = parseFloat(document.getElementById('udlFrom')?.value) || 0;
          const udlTo = parseFloat(document.getElementById('udlTo')?.value) || span1Length;
          span1Loads.push({ type: "udl", mag: span1LoadMag, from: udlFrom, to: udlTo });
        } else {
          span1Loads.push({ type: span1LoadType, mag: span1LoadMag, pos: span1LoadPos });
        }
      }
      // Extra loads for Span 1
      const span1LoadsContainer = document.querySelector('details .loadsContainer');
      if (span1LoadsContainer && span1LoadsContainer.children.length > 0) {
        Array.from(span1LoadsContainer.children).forEach(loadDiv => {
          const type = loadDiv.querySelector('input[type="radio"]:checked')?.value;
          let mag = 0, pos = 0;
          loadDiv.querySelectorAll('label').forEach(label => {
            if (label.textContent.trim().startsWith('Load Magnitude')) {
              mag = parseFloat(label.querySelector('input').value) || 0;
            }
            if (label.textContent.trim().startsWith('Load Position')) {
              pos = parseFloat(label.querySelector('input').value) || 0;
            }
          });
          if (type && mag > 0) {
            if (type === "udl") {
              const from = parseFloat(loadDiv.querySelector('.udlFrom')?.value) || 0;
              const to = parseFloat(loadDiv.querySelector('.udlTo')?.value) || span1Length;
              span1Loads.push({ type, mag, from, to });
            } else {
              span1Loads.push({ type, mag, pos });
            }
          }
        });
      }
      spans.push({ length: span1Length, loads: span1Loads });
    
      // Dynamic spans
      document.querySelectorAll('#spansContainer > details').forEach(details => {
        const spanDiv = details.querySelector('.span-fields');
        const length = parseFloat(spanDiv.querySelector('label input[type="number"]').value) || 1000;
        let loads = [];
        const mainType = spanDiv.querySelector('input[type="radio"]:checked').value;
        let mainMag = 0, mainPos = 0;
        spanDiv.querySelectorAll('label').forEach(label => {
          if (label.textContent.trim().startsWith('Load Magnitude')) {
            mainMag = parseFloat(label.querySelector('input').value) || 0;
          }
          if (label.textContent.trim().startsWith('Load Position')) {
            mainPos = parseFloat(label.querySelector('input').value) || 0;
          }
        });
        if (mainMag > 0) {
          if (mainType === "udl") {
            const udlFrom = parseFloat(spanDiv.querySelector('.udlFrom')?.value) || 0;
            const udlTo = parseFloat(spanDiv.querySelector('.udlTo')?.value) || length;
            loads.push({ type: "udl", mag: mainMag, from: udlFrom, to: udlTo });
          } else {
            loads.push({ type: mainType, mag: mainMag, pos: mainPos });
          }
        }
        // Extra loads
        const loadsContainer = spanDiv.querySelector('.loadsContainer');
        if (loadsContainer && loadsContainer.children.length > 0) {
          Array.from(loadsContainer.children).forEach(loadDiv => {
            const type = loadDiv.querySelector('input[type="radio"]:checked')?.value;
            let mag = 0, pos = 0;
            loadDiv.querySelectorAll('label').forEach(label => {
              if (label.textContent.trim().startsWith('Load Magnitude')) {
                mag = parseFloat(label.querySelector('input').value) || 0;
              }
              if (label.textContent.trim().startsWith('Load Position')) {
                pos = parseFloat(label.querySelector('input').value) || 0;
              }
            });
            if (type && mag > 0) {
              if (type === "udl") {
                const from = parseFloat(loadDiv.querySelector('.udlFrom')?.value) || 0;
                const to = parseFloat(loadDiv.querySelector('.udlTo')?.value) || length;
                loads.push({ type, mag, from, to });
              } else {
                loads.push({ type, mag, pos });
              }
            }
          });
        }
        spans.push({ length, loads });
      });
    
      // Get support moments from moment distribution (window.mdSupportMoments)
      const mdMoments = window.mdSupportMoments || [];
      if (mdMoments.length !== spans.length) {
        ctx.font = "16px Arial";
        ctx.fillStyle = "#c00";
        ctx.fillText("Run Moment Distribution first!", 50, 50);
        return;
      }
    
      // Drawing setup
      const margin = 40;
      const chartHeight = canvas.height - 40;
      const chartWidth = canvas.width - 2 * margin;
      const totalLength = spans.reduce((sum, s) => sum + s.length, 0);
      const scaleX = chartWidth / totalLength;
    
      // Calculate BMD points for all spans
      let points = [];
      let currentX = 0;
      for (let i = 0; i < spans.length; i++) {
        const span = spans[i];
        const L = span.length / 1000; // m
        const nSteps = 80;
        const M_A = mdMoments[i].left;   // kNm
        const M_B = mdMoments[i].right;  // kNm
    
        for (let step = 0; step <= nSteps; step++) {
          const x = (span.length * step) / nSteps; // mm
          const xm = x / 1000; // m
          let mx = 0;
          // End moments (linear part)
          mx += M_A * (1 - xm / L) + M_B * (xm / L);
    
          // Add effect of loads (parabolic for UDL, correct for point/moment)
          span.loads.forEach(load => {
            if (load.type === "udl") {
              let w = load.mag;
              let a = load.from !== undefined ? load.from / 1000 : 0;
              let b = load.to !== undefined ? load.to / 1000 : L;
              let l = b - a;
              if (l === L && a === 0) {
                // Full UDL, both ends fixed: M(x) = (w/12)*(L*x - x^3/L)
                mx += (w / 12) * (L * xm - Math.pow(xm, 3) / L);
              } else if (xm >= a && xm <= b) {
                // Partial UDL (approximate as simply supported for now)
                mx += w * Math.pow(xm - a, 2) / 2;
              } else if (xm > b) {
                mx += w * (b - a) * (xm - (a + b) / 2);
              }
            } else if (load.type === "point") {
              let P = load.mag;
              let a = load.pos / 1000 || 0;
              // Both ends fixed, moment at x due to P at a:
              // M(x) = P*a*(L-x)/L for x >= a, else P*(L-a)*x/L
              if (xm < a) {
                mx += P * (L - a) * xm / L;
              } else {
                mx += P * a * (L - xm) / L;
              }
            } else if (load.type === "moment") {
              let M0 = load.mag;
              let a = load.pos / 1000 || 0;
              // Both ends fixed, moment at x due to M0 at a:
              // M(x) = M0*(L-x)/L for x >= a, else M0*x/L
              if (xm < a) {
                mx += M0 * (L - a) / L;
              } else {
                mx += -M0 * a / L;
              }
            }
          });
    
          points.push({
            x: currentX + x,
            M: mx
          });
        }
        currentX += span.length;
      }
    
      // Find max/min for scaling
      const maxM = Math.max(...points.map(p => p.M));
      const minM = Math.min(...points.map(p => p.M));
      const scaleY = (chartHeight - 40) / (Math.abs(maxM) + Math.abs(minM) + 1e-6);
    
      // Draw axis
      ctx.strokeStyle = "#333";
      ctx.beginPath();
      ctx.moveTo(margin, chartHeight / 2 + 20);
      ctx.lineTo(margin + chartWidth, chartHeight / 2 + 20);
      ctx.stroke();
    
      // Draw BMD
      ctx.strokeStyle = "#2980B9";
      ctx.lineWidth = 2;
      ctx.beginPath();
      points.forEach((p, i) => {
        const x = margin + (p.x / totalLength) * chartWidth;
        const y = chartHeight / 2 + 20 - p.M * scaleY;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();
    
      // Labels
      ctx.fillStyle = "#2980B9";
      ctx.font = "12px Arial";
      ctx.fillText("Moment (kNm)", margin + 5, 15);
    }

    function drawSFD(canvasId = 'sfdCanvas') {
      const canvas = document.getElementById(canvasId);
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    
      // Gather spans and loads (same as drawBMD)
      let spans = [];
      const span1Length = parseFloat(document.getElementById('spanLength').value) || 1000;
      let span1Loads = [];
      const span1LoadType = document.querySelector('input[name="loadType"]:checked').value;
      const span1LoadMag = parseFloat(document.getElementById('UltimateLoad').value) || 0;
      const span1LoadPos = parseFloat(document.getElementById('loadPosition')?.value) || 0;
      if (span1LoadMag > 0) {
        if (span1LoadType === "udl") {
          const udlFrom = parseFloat(document.getElementById('udlFrom')?.value) || 0;
          const udlTo = parseFloat(document.getElementById('udlTo')?.value) || span1Length;
          span1Loads.push({ type: "udl", mag: span1LoadMag, from: udlFrom, to: udlTo });
        } else {
          span1Loads.push({ type: span1LoadType, mag: span1LoadMag, pos: span1LoadPos });
        }
      }
      const span1LoadsContainer = document.querySelector('details .loadsContainer');
      if (span1LoadsContainer && span1LoadsContainer.children.length > 0) {
        Array.from(span1LoadsContainer.children).forEach(loadDiv => {
          const type = loadDiv.querySelector('input[type="radio"]:checked')?.value;
          let mag = 0, pos = 0;
          loadDiv.querySelectorAll('label').forEach(label => {
            if (label.textContent.trim().startsWith('Load Magnitude')) {
              mag = parseFloat(label.querySelector('input').value) || 0;
            }
            if (label.textContent.trim().startsWith('Load Position')) {
              pos = parseFloat(label.querySelector('input').value) || 0;
            }
          });
          if (type && mag > 0) {
            if (type === "udl") {
              const from = parseFloat(loadDiv.querySelector('.udlFrom')?.value) || 0;
              const to = parseFloat(loadDiv.querySelector('.udlTo')?.value) || span1Length;
              span1Loads.push({ type, mag, from, to });
            } else {
              span1Loads.push({ type, mag, pos });
            }
          }
        });
      }
      spans.push({ length: span1Length, loads: span1Loads });
    
      // Dynamic spans
      document.querySelectorAll('#spansContainer > details').forEach(details => {
        const spanDiv = details.querySelector('.span-fields');
        const length = parseFloat(spanDiv.querySelector('label input[type="number"]').value) || 1000;
        let loads = [];
        const mainType = spanDiv.querySelector('input[type="radio"]:checked').value;
        let mainMag = 0, mainPos = 0;
        spanDiv.querySelectorAll('label').forEach(label => {
          if (label.textContent.trim().startsWith('Load Magnitude')) {
            mainMag = parseFloat(label.querySelector('input').value) || 0;
          }
          if (label.textContent.trim().startsWith('Load Position')) {
            mainPos = parseFloat(label.querySelector('input').value) || 0;
          }
        });
        if (mainMag > 0) {
          if (mainType === "udl") {
            const udlFrom = parseFloat(spanDiv.querySelector('.udlFrom')?.value) || 0;
            const udlTo = parseFloat(spanDiv.querySelector('.udlTo')?.value) || length;
            loads.push({ type: "udl", mag: mainMag, from: udlFrom, to: udlTo });
          } else {
            loads.push({ type: mainType, mag: mainMag, pos: mainPos });
          }
        }
        const loadsContainer = spanDiv.querySelector('.loadsContainer');
        if (loadsContainer && loadsContainer.children.length > 0) {
          Array.from(loadsContainer.children).forEach(loadDiv => {
            const type = loadDiv.querySelector('input[type="radio"]:checked')?.value;
            let mag = 0, pos = 0;
            loadDiv.querySelectorAll('label').forEach(label => {
              if (label.textContent.trim().startsWith('Load Magnitude')) {
                mag = parseFloat(label.querySelector('input').value) || 0;
              }
              if (label.textContent.trim().startsWith('Load Position')) {
                pos = parseFloat(label.querySelector('input').value) || 0;
              }
            });
            if (type && mag > 0) {
              if (type === "udl") {
                const from = parseFloat(loadDiv.querySelector('.udlFrom')?.value) || 0;
                const to = parseFloat(loadDiv.querySelector('.udlTo')?.value) || length;
                loads.push({ type, mag, from, to });
              } else {
                loads.push({ type, mag, pos });
              }
            }
          });
        }
        spans.push({ length, loads });
      });
    
      // Get support moments from moment distribution (window.mdSupportMoments)
      const mdMoments = window.mdSupportMoments || [];
      if (mdMoments.length !== spans.length) {
        ctx.font = "16px Arial";
        ctx.fillStyle = "#c00";
        ctx.fillText("Run Moment Distribution first!", 50, 50);
        return;
      }
    
      // Calculate reactions at supports using moments and loads
      // For each span, calculate reactions at left and right using:
      // V_left = (M_left + M_right)/L + sum of vertical loads (UDL, point, etc.)
      // For continuous beams, reactions are shared at supports
    
      // Drawing setup
      const margin = 40;
      const chartHeight = canvas.height - 40;
      const chartWidth = canvas.width - 2 * margin;
      const totalLength = spans.reduce((sum, s) => sum + s.length, 0);
      const scaleX = chartWidth / totalLength;
    
      // Calculate SFD points for all spans
      let points = [];
      let currentX = 0;
      let prevShear = 0;
      for (let i = 0; i < spans.length; i++) {
        const span = spans[i];
        const L = span.length / 1000; // m
        const nSteps = 80;
        const M_A = mdMoments[i].left;   // kNm
        const M_B = mdMoments[i].right;  // kNm
    
        // Calculate total vertical load on span
        let totalUDL = 0;
        span.loads.forEach(load => {
          if (load.type === "udl") {
            let a = load.from !== undefined ? load.from / 1000 : 0;
            let b = load.to !== undefined ? load.to / 1000 : L;
            let l = b - a;
            totalUDL += load.mag * l;
          }
          if (load.type === "point") {
            totalUDL += load.mag;
          }
        });
    
        // Calculate reactions at left and right (for simply supported, use standard formulas)
        // For continuous, use moments and loads
        // V_left = (M_A + M_B)/L + sum of vertical loads / 2 (approximate for continuous)
        // For more accuracy, use equilibrium at each support
        let V_left = null, V_right = null;
        // For simply supported: V_left = totalUDL/2, V_right = totalUDL/2
        // For continuous: V_left = (M_A + M_B)/L + ... (approximate)
        V_left = (M_A + M_B) / L + totalUDL / 2;
        V_right = totalUDL - V_left;
    
        for (let step = 0; step <= nSteps; step++) {
          const x = (span.length * step) / nSteps; // mm
          const xm = x / 1000; // m
          let shear = V_left;
    
          // Subtract UDL up to x
          span.loads.forEach(load => {
            if (load.type === "udl") {
              let a = load.from !== undefined ? load.from / 1000 : 0;
              let b = load.to !== undefined ? load.to / 1000 : L;
              let l = b - a;
              if (xm >= a && xm <= b) {
                shear -= load.mag * (xm - a);
              } else if (xm > b) {
                shear -= load.mag * l;
              }
            }
            if (load.type === "point") {
              let a = load.pos / 1000 || 0;
              if (xm >= a) {
                shear -= load.mag;
              }
            }
          });
    
          points.push({
            x: currentX + x,
            V: shear
          });
        }
        currentX += span.length;
      }
    
      // Find max/min for scaling
      const maxV = Math.max(...points.map(p => p.V));
      const minV = Math.min(...points.map(p => p.V));
      const scaleY = chartHeight / (Math.abs(maxV) + Math.abs(minV) + 1e-6);
    
      // Draw axis
      ctx.strokeStyle = "#333";
      ctx.beginPath();
      ctx.moveTo(margin, chartHeight / 2 + 20);
      ctx.lineTo(margin + chartWidth, chartHeight / 2 + 20);
      ctx.stroke();
    
      // Draw SFD
      ctx.strokeStyle = "#E67E22";
      ctx.lineWidth = 2;
      ctx.beginPath();
      points.forEach((p, i) => {
        const x = margin + (p.x / totalLength) * chartWidth;
        const y = chartHeight / 2 + 20 - p.V * scaleY;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();
    
      // Labels
      ctx.fillStyle = "#E67E22";
      ctx.font = "12px Arial";
      ctx.fillText("Shear (kN)", margin + 5, 15);
    }

    function showDiagrams() {
      // Always update spans and loads before running moment distribution
      MomentDistribution.updateTable();
      drawFBDAllSpans('resultFBDCanvas');
      drawSFD('resultSFDCanvas');
      drawBMD('resultBMDCanvas');
    }
    
    document.addEventListener('input', drawFBDAllSpans);
    document.addEventListener('change', drawFBDAllSpans);
    window.addEventListener('DOMContentLoaded', () => {
      drawFBDAllSpans();
      updateLoadPositionUI();
    });

    //---Calculation Logic---
    let fullResult = "";
    let lastCalc = {};
    function calculate() {
      let result = "";
      const type = document.getElementById("beamType").value;
      const h = parseFloat(document.getElementById("beamDepth").value);
      const b = parseFloat(document.getElementById("beamWidth").value);
      const flangeDepth = parseFloat(document.getElementById("flangeDepth")?.value) || b;
      const fck = parseFloat(document.getElementById("fck").value);
      const fyk = parseFloat(document.getElementById("fyk").value);
      const dia = parseFloat(document.getElementById("barDiameter").value);
      const linkDia = parseFloat(document.getElementById("linkDiameter").value);
      const cover = parseFloat(document.getElementById("concreteCover").value);
    
      // --- Gather all spans (including Span 1 and dynamic spans) ---
      let spans = [];
    
      // Span 1
      const span1Length = parseFloat(document.getElementById('spanLength').value) || 1000;
      let span1Loads = [];
    
      // Self Weight for Span 1
      const density = parseFloat(document.getElementById("concreteDensity").value) || 25;
      const width = b / 1000; // m
      const depth = h / 1000; // m
      const selfWeight = density * width * depth; // kN/m
      span1Loads.push({ type: "udl", mag: selfWeight, from: 0, to: span1Length });
    
      // Main load for Span 1
      const span1LoadType = document.querySelector('input[name="loadType"]:checked').value;
      const span1LoadMag = parseFloat(document.getElementById('UltimateLoad').value) || 0;
      if (span1LoadType === "udl") {
        const udlFrom = parseFloat(document.getElementById('udlFrom')?.value) || 0;
        const udlTo = parseFloat(document.getElementById('udlTo')?.value) || span1Length;
        if (span1LoadMag > 0 && udlTo > udlFrom) {
          span1Loads.push({ type: "udl", mag: span1LoadMag, from: udlFrom, to: udlTo });
        }
      } else {
        const span1LoadPos = parseFloat(document.getElementById('loadPosition')?.value) || 0;
        if (span1LoadMag > 0) {
          span1Loads.push({ type: span1LoadType, mag: span1LoadMag, pos: span1LoadPos });
        }
      }
      // Extra loads for Span 1
      const span1LoadsContainer = document.querySelector('details .loadsContainer');
      if (span1LoadsContainer && span1LoadsContainer.children.length > 0) {
        Array.from(span1LoadsContainer.children).forEach(loadDiv => {
          const type = loadDiv.querySelector('input[type="radio"]:checked')?.value;
          let mag = 0, pos = 0;
          loadDiv.querySelectorAll('label').forEach(label => {
            if (label.textContent.trim().startsWith('Load Magnitude')) {
              mag = parseFloat(label.querySelector('input').value) || 0;
            }
          });
          if (type === "udl") {
            const from = parseFloat(loadDiv.querySelector('.udlFrom')?.value) || 0;
            const to = parseFloat(loadDiv.querySelector('.udlTo')?.value) || 0;
            if (mag > 0 && to > from) {
              span1Loads.push({ type, mag, from, to });
            }
          } else {
            pos = parseFloat(loadDiv.querySelector('.loadPosition')?.value) || 0;
            if (type && mag > 0) {
              span1Loads.push({ type, mag, pos });
            }
          }
        });
      }
      spans.push({ length: span1Length, loads: span1Loads });
    
      // Dynamic spans
      document.querySelectorAll('#spansContainer > details').forEach(details => {
        const spanDiv = details.querySelector('.span-fields');
        const length = parseFloat(spanDiv.querySelector('label input[type="number"]').value) || 1000;
        let loads = [];
        // Main load
        const mainType = spanDiv.querySelector('input[type="radio"]:checked').value;
        let mainMag = 0, mainPos = 0;
        spanDiv.querySelectorAll('label').forEach(label => {
          if (label.textContent.trim().startsWith('Load Magnitude')) {
            mainMag = parseFloat(label.querySelector('input').value) || 0;
          }
          if (label.textContent.trim().startsWith('Load Position')) {
            mainPos = parseFloat(label.querySelector('input').value) || 0;
          }
        });
        if (mainMag > 0) {
          loads.push({ type: mainType, mag: mainMag, pos: mainPos });
        }
        // Extra loads
        const loadsContainer = spanDiv.querySelector('.loadsContainer');
        if (loadsContainer && loadsContainer.children.length > 0) {
          Array.from(loadsContainer.children).forEach(loadDiv => {
            const type = loadDiv.querySelector('input[type="radio"]:checked')?.value;
            let mag = 0, pos = 0;
            loadDiv.querySelectorAll('label').forEach(label => {
              if (label.textContent.trim().startsWith('Load Magnitude')) {
                mag = parseFloat(label.querySelector('input').value) || 0;
              }
              if (label.textContent.trim().startsWith('Load Position')) {
                pos = parseFloat(label.querySelector('input').value) || 0;
              }
            });
            if (type && mag > 0) {
              loads.push({ type, mag, pos });
            }
          });
        }
        // Self weight for each dynamic span
        loads.push({ type: "udl", mag: selfWeight, from: 0, to: length });
        spans.push({ length, loads });
      });
    
      // --- Find global maximum moment and shear ---
      let globalMaxM = null, globalMaxV = null;
      let globalMspan = 0, globalMshear = 0;
    
      spans.forEach((span, spanIdx) => {
        const spanLength = span.length;
        const span_m = spanLength / 1000;
        const loads = span.loads;
    
        // Find critical positions for this span
        let criticalPositions = [spanLength / 2];
        loads.forEach(load => {
          if (load.type === "point" || load.type === "moment") {
            criticalPositions.push(load.pos);
          }
          if (load.type === "udl") {
            criticalPositions.push(load.from, load.to);
          }
        });
        criticalPositions = Array.from(new Set(criticalPositions)).filter(x => x >= 0 && x <= spanLength);
    
        criticalPositions.forEach(x_mm => {
          let x = x_mm / 1000; // m
          let M = 0; // kNm
          let V = 0; // kN
    
          loads.forEach(load => {
            if (load.type === "udl") {
              const a = (load.from || 0) / 1000;
              const b = (load.to || spanLength) / 1000;
              const w = load.mag; // kN/m
              if (x < a) {
                // No effect
              } else if (x >= a && x <= b) {
                M += w * Math.pow(x - a, 2) / 2;
                V += w * (b - x);
              } else if (x > b) {
                M += w * (b - a) * (x - (a + b) / 2);
                // V = 0
              }
            }
            if (load.type === "point") {
              const P = load.mag; // kN
              const a = (load.pos || 0) / 1000;
              const L = span_m;
              if (x < a) {
                M += P * (L - a) * x / L;
                V += P * (L - a) / L;
              } else {
                M += P * a * (L - x) / L;
                V += -P * a / L;
              }
            }
            if (load.type === "moment") {
              const M0 = load.mag; // kNm
              const a = (load.pos || 0) / 1000;
              const L = span_m;
              if (x < a) {
                M += M0 * (L - a) / L;
                V += -M0 / L;
              } else {
                M += -M0 * a / L;
                V += M0 / L;
              }
            }
          });
    
          if (globalMaxM === null || Math.abs(M) > Math.abs(globalMaxM)) {
            globalMaxM = M;
            globalMspan = M * 1e6; // Nmm
          }
          if (globalMaxV === null || Math.abs(V) > Math.abs(globalMaxV)) {
            globalMaxV = V;
            globalMshear = V;
          }
        });
      });
    
      // --- Section Design ---
      const d = (h - cover - linkDia - (dia / 2));
      let beff = b;
      let hf = 0;
      if (type === "tbeam" || type === "lbeam") {
        beff = parseFloat(document.getElementById("beffInput").value) || b;
        hf = parseFloat(document.getElementById("flangeDepth").value) || 0;
      } else {
        beff = b;
        hf = 0;
      }
    
      const k = globalMspan / (beff * Math.pow(d, 2) * fck);
      const Ztemp = d * (0.5 + Math.sqrt(0.25 - (k / 1.134)));
      Z = Ztemp > 0.95 * d ? 0.95 * d : Ztemp;
      const S = 2 * (d - Z);
    
      result += `<strong>Maximum Moment (Mspan):</strong> ${(globalMspan/1e6).toFixed(2)} kNm<br>`;
      result += `<strong>Maximum Shear (Mshear):</strong> ${globalMshear.toFixed(2)} kN<br>`;
      result += `<strong>K:</strong> ${k.toFixed(4)}<br>`;
      result += `<strong>Z:</strong> ${Z.toFixed(2)} mm<br>`;
      result += `<strong>S:</strong> ${S.toFixed(2)} mm<br>`;
    
      if ((type === "tbeam" || type === "lbeam") && S <= hf) {
        result += "The stress block is within the flange.<br>";
        As = globalMspan / (0.87 * fyk * Z);
        result += `<strong>Required Area of Steel As:</strong> ${As.toFixed(2)} mm²<br>`;
        result += `<label>Enter Provided Area of Steel (from table, mm²):</label>
          <input type='number' id='providedAs' />
          <button type="button" onclick="continueCalc()">Result</button>`;
        lastCalc = { As_req: As, b, d, fck, fyk, M: globalMspan, SpanLength: span1Length, beff, bw: b, globalMshear: globalMshear, w: selfWeight };
      }
      else if ((type === "tbeam" || type === "lbeam") && S > hf) {
        // Check K for singly/doubly reinforced
        const bw = b;
        const bf = beff;
        const d_dash = h - d;
        let xu = d / 2;
        let xu_prev = 0;
        let iter = 0;
        let Cf, Cw, C, Ast_lim, Mlim;
        const maxIter = 100;
        const tol = 1e-3;
        while (Math.abs(xu - xu_prev) > tol && iter < maxIter) {
          xu_prev = xu;
          Cf = 0.45 * fck * bf * hf;
          Cw = 0.36 * fck * bw * (xu - hf > 0 ? xu - hf : 0);
          C = Cf + Cw;
          Mlim = Cf * (d - 0.5 * hf) + Cw * (d - 0.42 * (xu - hf > 0 ? xu - hf : 0));
          if (Mlim < globalMspan) xu += 5;
          else xu -= 2;
          iter++;
          if (xu > d) xu = d;
          if (xu < hf) xu = hf + 1;
        }
        Ast_lim = C / (0.87 * fyk);
        result += `<strong>Neutral axis depth (xu):</strong> ${xu.toFixed(2)} mm<br>`;
        result += `<strong>Compression in flange (Cf):</strong> ${Cf.toFixed(2)} N<br>`;
        result += `<strong>Compression in web (Cw):</strong> ${Cw.toFixed(2)} N<br>`;
        result += `<strong>Total compression (C):</strong> ${C.toFixed(2)} N<br>`;
        result += `<strong>Moment of resistance (Mlim):</strong> ${(Mlim/1e6).toFixed(2)} kNm<br>`;
        result += `<strong>Required Area of Tension Steel (Ast):</strong> ${Ast_lim.toFixed(2)} mm²<br>`;
        // Calculate K for doubly/singly reinforced check
        const K = globalMspan / (beff * Math.pow(d, 2) * fck);
        // Only one reinforcement check block needed here
        if (K < 0.167) {
          // Singly reinforced
          result += `<strong>Section is Singly Reinforced (K = ${K.toFixed(4)} < 0.167)</strong><br>`;
          result += `<label>Enter Provided Area of Steel (from table, mm²):</label>
            <input type='number' id='providedAs' />
            <button type="button" onclick="continueCalc()">Result</button>`;
          lastCalc = { As_req: Ast_lim, b, d, fck, fyk, M: globalMspan, SpanLength: span1Length, beff, bw, globalMshear, w: selfWeight };
        } else {
          // Doubly reinforced
          result += `<strong>Section is Doubly Reinforced (K = ${K.toFixed(4)} > 0.167)</strong><br>`;
          const Asc = (globalMspan - Mlim) / (0.87 * fyk * (d - d_dash));
          result += `<strong>Required Compression Steel (Asc):</strong> ${Asc.toFixed(2)} mm²<br>`;
          result += `<label>Enter Provided Compression Steel (mm²):</label>
            <input type='number' id='providedAsPrime' /><br>`;
          result += `<label>Enter Provided Tension Steel (mm²):</label>
            <input type='number' id='providedAs' /><br>
            <button type="button" onclick="checkDoublySteel()">Check Steel</button>`;
          lastCalc = { As_req: Ast_lim + Asc, As_prime_req: Asc, b, d, fck, fyk, M: globalMspan, SpanLength: span1Length, beff, bw, globalMshear, w: selfWeight };
        }
      }
      else {
        // Rectangular or doubly reinforced
        const d_dash = h - d;
        Z = 0.82 * d;
        const K = globalMspan / (b * Math.pow(d, 2) * fck);
        let As_prime = 0;
        const As = (0.167 * fck * b * Math.pow(d, 2)) / (0.87 * fyk * Z);
        if (K > 0.167) {
          result += `<strong>Section is Doubly Reinforced (K = ${K.toFixed(4)} > 0.167)</strong><br>`;
          As_prime = ((K - 0.167) * fck * b * Math.pow(d, 2)) / (0.87 * fyk * (d - d_dash));
          result += `<strong>Required Compression Steel (As'): </strong>${As_prime.toFixed(2)} mm²<br>`;
          result += `<label>Enter Provided Compression Steel (mm²):</label>
            <input type='number' id='providedAsPrime' /><br>`;
        } else {
          result += `<strong>Section is Singly Reinforced (K = ${K.toFixed(4)} ≤ 0.167)</strong><br>`;
          result += `<strong>No compression steel required.</strong><br>`;
        }
        result += `<strong>Required Tension Steel (As): </strong>${As.toFixed(2)} mm²<br>`;
        result += `<label>Enter Provided Tension Steel (mm²):</label>
          <input type='number' id='providedAs' /><br>
          <button type="button" onclick="checkDoublySteel()">Check Steel</button>`;
        lastCalc = { As_req: As, As_prime_req: As_prime, b, d, fck, fyk, M: globalMspan, SpanLength: span1Length, beff, bw: b, globalMshear, w: selfWeight };
      }
    
      // Always update the results area at the end:
      document.getElementById("resultsContent").innerHTML = result + `<div id="steelCheckArea"></div>`;
      document.getElementById("resultArea").style.display = "block";
      document.getElementById("downloadBtn").style.display = "none"; // Hide until steel check
    
      // Now draw the diagrams on the new canvases
      drawFBDAllSpans();
      drawSFD();
      drawBMD();
    }
    showDiagrams();

    function checkDoublySteel() {
      const As_prov = parseFloat(document.getElementById("providedAs").value);
      let As_prime_prov = 0;
      const AsPrimeInput = document.getElementById("providedAsPrime");
      if (AsPrimeInput) {
        As_prime_prov = parseFloat(AsPrimeInput.value) || 0;
      }

      const { As_req, As_prime_req } = lastCalc;
      let result = "";

      if (AsPrimeInput) {
        result += `<br><strong>Provided Compression Steel:</strong> ${As_prime_prov.toFixed(2)} mm²<br>`;
        result += (As_prime_prov >= As_prime_req)
          ? "<strong>Compression steel is sufficient.</strong><br>"
          : "<strong>Compression steel is NOT sufficient.</strong><br>";
      }

      result += `<br><strong>Provided Tension Steel:</strong> ${As_prov.toFixed(2)} mm²<br>`;
      result += (As_prov >= As_req)
        ? "<strong>Tension steel is sufficient.</strong><br>"
        : "<strong>Tension steel is NOT sufficient.</strong><br>";

      const steelCheckArea = document.getElementById("steelCheckArea");
      // Remove previous tables and diagrams
      while (steelCheckArea.firstChild) steelCheckArea.removeChild(steelCheckArea.firstChild);

      // Add result summary
      const resultDiv = document.createElement('div');
      resultDiv.innerHTML = result;
      steelCheckArea.appendChild(resultDiv);

      // Add FEM table
      showFEMResults();

      // Add Moment Distribution table
      MomentDistribution.updateTable();

      // Add diagrams
      const diagramsDiv = document.createElement('div');
      diagramsDiv.id = "beamDiagrams";
      diagramsDiv.innerHTML = `
        <h2>Free Body Diagram</h2>
        <canvas id="resultFBDCanvas" width="600" height="300" style="border:1px solid #ccc; margin-bottom:20px;"></canvas>
        <h2>Shear Force Diagram</h2>
        <canvas id="resultSFDCanvas" width="600" height="120" style="border:1px solid #ccc; margin-bottom:20px;"></canvas>
        <h2>Bending Moment Diagram</h2>
        <canvas id="resultBMDCanvas" width="600" height="120" style="border:1px solid #ccc; margin-bottom:20px;"></canvas>
      `;
      steelCheckArea.appendChild(diagramsDiv);

      document.getElementById("downloadBtn").style.display = ""; // Show after steel check

      // Draw the diagrams now that canvases exist
      drawFBDAllSpans('beamCanvas');
      drawFBDAllSpans('resultFBDCanvas');
      drawSFD('sfdCanvas');
      drawSFD('resultSFDCanvas');
      drawBMD('bmdCanvas');
      drawBMD('resultBMDCanvas');
    }

    function continueCalc() {
      const As_prov = parseFloat(document.getElementById("providedAs").value);
      let result = "";

      // Use lastCalc values
      const { As_req, b, d, fck, fyk, M, SpanLength, beff, bw, globalMshear, w } = lastCalc;

      const As_min = (0.26 * 0.3 * Math.pow(fck, 2/3) * b * d) / fyk;
      result += `<br><strong>Minimum As required:</strong> ${As_min.toFixed(2)} mm²<br>`;
      result += (As_prov >= As_min) ? "Not under-reinforced<br>" : "Under-reinforced<br>";

      const Ac = b * d;
      const percent = (100 * As_prov) / Ac;
      result += `<strong>Steel %:</strong> ${percent.toFixed(2)}%<br>`;

      const p = As_req / (b * d);
      const p0 = Math.sqrt(fck) / 1000;
      result += `<strong>Deflection Check:</strong><br>p = ${p.toFixed(5)}, p0 = ${p0.toFixed(5)}<br>`;
      
      if (p > p0) {
        const l_d = 1.5 * (11 + 1.5 * Math.sqrt(fck) * (p0 / (p - p0)) + (1 / 12) * Math.sqrt(fck) * Math.sqrt(p0 / p));
        const qs = (310 * fyk * As_req) / (500 * As_prov)
        const Mod_1 = 310 / qs
        const Mod_2 = beff / bw
        const Mod_3 = 1
        const l_d_Actual = SpanLength / d
        const l_d_Allow = l_d * Mod_1 * Mod_2 * Mod_3
        result += `l/d Allowable= ${l_d_Allow.toFixed(2)}<br>`;
        result += `l/d Actual= ${l_d_Actual.toFixed(2)}<br>`;

      if (l_d_Actual < l_d_Allow){
        result += '<strong>It will not Deflect</strong><br>'
      }
      else {
        result += '<strong>It will Deflect</strong>'
      }
      }
      else {
        result += `p < p0: It will Deflect <br>`;
      }
      
      const Ved = globalMshear - ((w * (d/1000))/2);
      const Vrdmax = 0.124 * (bw * d / 1000) * (1 - (fck / 250)) * fck; 
      if (Vrdmax > Ved) {
        const angleInDegrees = 22;
        const angleInRadians = angleInDegrees * Math.PI / 180;
        const cotValue = 1 / Math.tan(angleInRadians);
        const Asw_S = (Ved * 1000) / (0.78 * d * fyk * 2.5)
        const Asw_Min_S = (0.08 * Math.pow(fck,0.5) * bw) / fyk
        result += `<strong>Shear Check:</strong><br>Ved = ${Ved.toFixed(2)} KN, Vrdmax = ${Vrdmax.toFixed(2)} KN<br>`;
        result += "<strong>It will not shear</strong><br>";
      }
      else {
        result += `<strong>Shear Check:</strong><br>Ved = ${Ved.toFixed(2)} KN, Vrdmax = ${Vrdmax.toFixed(2)} KN<br>`;
        result += '<strong>It will Shear</strong><br>';
      }
      document.getElementById("steelCheckArea").innerHTML = result +
        `<div id="beamDiagrams">
          <h2>Free Body Diagram</h2>
          <canvas id="resultFBDCanvas" width="600" height="300" style="border:1px solid #ccc; margin-bottom:20px;"></canvas>
          <h2>Shear Force Diagram</h2>
          <canvas id="resultSFDCanvas" width="600" height="120" style="border:1px solid #ccc; margin-bottom:20px;"></canvas>
          <h2>Bending Moment Diagram</h2>
          <canvas id="resultBMDCanvas" width="600" height="120" style="border:1px solid #ccc; margin-bottom:20px;"></canvas>
        </div>`;
      document.getElementById("downloadBtn").style.display = ""; // Show after steel check
      showFEMResults();
      // Draw the diagrams after DOM update
      setTimeout(() => {
        drawFBDAllSpans('beamCanvas');
        drawFBDAllSpans('resultFBDCanvas');
        drawSFD('sfdCanvas');
        drawSFD('resultSFDCanvas');
        drawBMD('bmdCanvas');
        drawBMD('resultBMDCanvas');
        MomentDistribution.updateTable();
      }, 50);
    }

    function tension() {
      const As_prov = parseFloat(document.getElementById("providedA_s").value);
      let result = "";

      // Use lastCalc values
      const { As_req, b, d, fck, fyk, M, SpanLength, beff, bw, globalMshear, w } = lastCalc;

      // Example: Check if provided tension steel is sufficient
      result += `<br><strong>Provided Tension Steel:</strong> ${As_prov.toFixed(2)} mm²<br>`;
      if (As_prov >= As_req) {
        result += "<strong>Tension steel is sufficient.</strong><br>";
      } else {
        result += "<strong>Tension steel is NOT sufficient.</strong><br>";
      }

      const steelCheckArea = document.getElementById("steelCheckArea");
      // Remove previous tables and diagrams
      while (steelCheckArea.firstChild) steelCheckArea.removeChild(steelCheckArea.firstChild);

      // Add result summary
      const resultDiv = document.createElement('div');
      resultDiv.innerHTML = result;
      steelCheckArea.appendChild(resultDiv);

      // Add FEM table
      showFEMResults();

      // Add Moment Distribution table
      MomentDistribution.updateTable();

      // Add diagrams
      const diagramsDiv = document.createElement('div');
      diagramsDiv.id = "beamDiagrams";
      diagramsDiv.innerHTML = `
        <h2>Free Body Diagram</h2>
        <canvas id="resultFBDCanvas" width="600" height="300" style="border:1px solid #ccc; margin-bottom:20px;"></canvas>
        <h2>Shear Force Diagram</h2>
        <canvas id="resultSFDCanvas" width="600" height="120" style="border:1px solid #ccc; margin-bottom:20px;"></canvas>
        <h2>Bending Moment Diagram</h2>
        <canvas id="resultBMDCanvas" width="600" height="120" style="border:1px solid #ccc; margin-bottom:20px;"></canvas>
      `;
      steelCheckArea.appendChild(diagramsDiv);

      document.getElementById("downloadBtn").style.display = ""; // Show after steel check

      // Draw the diagrams now that canvases exist
      drawFBDAllSpans('beamCanvas');
      drawFBDAllSpans('resultFBDCanvas');
      drawSFD('sfdCanvas');
      drawSFD('resultSFDCanvas');
      drawBMD('bmdCanvas');
      drawBMD('resultBMDCanvas');
    }

    function showFEMResults() {
      // Gather all spans and their loads (same logic as drawFBDAllSpans)
      let spans = [];
    
      // Span 1
      const span1Length = parseFloat(document.getElementById('spanLength').value) || 1000;
      let span1Loads = [];
    
      // Main load for Span 1
      const span1LoadType = document.querySelector('input[name="loadType"]:checked').value;
      const span1LoadMag = parseFloat(document.getElementById('UltimateLoad').value) || 0;
      if (span1LoadType === "udl") {
        const udlFrom = parseFloat(document.getElementById('udlFrom')?.value) || 0;
        const udlTo = parseFloat(document.getElementById('udlTo')?.value) || span1Length;
        if (span1LoadMag > 0 && udlTo > udlFrom) {
          span1Loads.push({ type: "udl", mag: span1LoadMag, from: udlFrom, to: udlTo });
        }
      } else {
        const span1LoadPos = parseFloat(document.getElementById('loadPosition')?.value) || 0;
        if (span1LoadMag > 0) {
          span1Loads.push({ type: span1LoadType, mag: span1LoadMag, pos: span1LoadPos });
        }
      }
      // Extra loads for Span 1
      const span1LoadsContainer = document.querySelector('details .loadsContainer');
      if (span1LoadsContainer && span1LoadsContainer.children.length > 0) {
        Array.from(span1LoadsContainer.children).forEach(loadDiv => {
          const type = loadDiv.querySelector('input[type="radio"]:checked')?.value;
          let mag = 0, pos = 0;
          loadDiv.querySelectorAll('label').forEach(label => {
            if (label.textContent.trim().startsWith('Load Magnitude')) {
              mag = parseFloat(label.querySelector('input').value) || 0;
            }
          });
          if (type === "udl") {
            const from = parseFloat(loadDiv.querySelector('.udlFrom')?.value) || 0;
            const to = parseFloat(loadDiv.querySelector('.udlTo')?.value) || 0;
            if (mag > 0 && to > from) {
              span1Loads.push({ type, mag, from, to });
            }
          } else {
            const pos = parseFloat(loadDiv.querySelector('.loadPosition')?.value) || 0;
            if (type && mag > 0) {
              span1Loads.push({ type, mag, pos });
            }
          }
        });
      }
      spans.push({ length: span1Length, loads: span1Loads });
    
      // Dynamic spans
      document.querySelectorAll('#spansContainer > details').forEach(details => {
        const spanDiv = details.querySelector('.span-fields');
        const length = parseFloat(spanDiv.querySelector('label input[type="number"]').value) || 1000;
        let loads = [];
        // Main load
        const mainType = spanDiv.querySelector('input[type="radio"]:checked').value;
        let mainMag = 0, mainPos = 0;
        spanDiv.querySelectorAll('label').forEach(label => {
          if (label.textContent.trim().startsWith('Load Magnitude')) {
            mainMag = parseFloat(label.querySelector('input').value) || 0;
          }
          if (label.textContent.trim().startsWith('Load Position')) {
            mainPos = parseFloat(label.querySelector('input').value) || 0;
          }
        });
        if (mainMag > 0) {
          loads.push({ type: mainType, mag: mainMag, pos: mainPos });
        }
        // Extra loads
        const loadsContainer = spanDiv.querySelector('.loadsContainer');
        if (loadsContainer && loadsContainer.children.length > 0) {
          Array.from(loadsContainer.children).forEach(loadDiv => {
            const type = loadDiv.querySelector('input[type="radio"]:checked')?.value;
            let mag = 0, pos = 0;
            loadDiv.querySelectorAll('label').forEach(label => {
              if (label.textContent.trim().startsWith('Load Magnitude')) {
                mag = parseFloat(label.querySelector('input').value) || 0;
              }
              if (label.textContent.trim().startsWith('Load Position')) {
                pos = parseFloat(label.querySelector('input').value) || 0;
              }
            });
            if (type && mag > 0) {
              loads.push({ type, mag, pos });
            }
          });
        }
        spans.push({ length, loads });
      });
    
      // Calculate FEMs for each span (sum all loads)
      let femResults = [];
      spans.forEach((span, idx) => {
        let L = span.length;
        let M_A = 0, M_B = 0;
        span.loads.forEach(load => {
          if (load.type === "udl") {
            // For full UDL (from 0 to L)
            let w = load.mag;
            let a = load.from !== undefined ? load.from : 0;
            let b = load.to !== undefined ? load.to : L;
            let l = b - a;
            if (l === L && a === 0) {
              // Full UDL
              M_A += -w * Math.pow(L, 2) / 12;
              M_B += w * Math.pow(L, 2) / 12;
            } else {
              // Partial UDL
              // M(AB) = -(w * l) * (L - (l/2) - a) / 12
              // M(BA) = (w * l) * ((l/2) + a) / 12
              M_A += -(w * l) * (L - (l / 2) - a) / 12;
              M_B += (w * l) * ((l / 2) + a) / 12;
            }
          } else if (load.type === "point") {
            let P = load.mag;
            let a = load.pos || 0;
            let b = L - a;
            // M(AB) = -P * b^2 * a / L^2
            // M(BA) = P * a^2 * b / L^2
            M_A += -P * Math.pow(b, 2) * a / Math.pow(L, 2);
            M_B += P * Math.pow(a, 2) * b / Math.pow(L, 2);
          } else if (load.type === "moment") {
            let M = load.mag;
            let a = load.pos || 0;
            // M(AB) = M * (1 - a/L)
            // M(BA) = M * (a/L)
            M_A += M * (1 - a / L);
            M_B += M * (a / L);
          }
        });
        femResults.push({
          span: idx + 1,
          length: L,
          M_A: M_A,
          M_B: M_B
        });
      });
    
      // Build HTML table
      let html = `<h3>Fixed-End Moments (FEM) for Each Span</h3>
        <table border="1" cellpadding="4" style="border-collapse:collapse;">
          <thead>
            <tr><th>Span</th><th>Length (mm)</th><th>FEM at Left (M<sub>A</sub>)</th><th>FEM at Right (M<sub>B</sub>)</th></tr>
          </thead>
          <tbody>`;
      femResults.forEach(r => {
        // Convert length from mm to m, FEM from Nm to kNm
        const length_m = (r.length / 1000).toFixed(2);
        const M_A_kNm = (r.M_A / 1000).toFixed(2);
        const M_B_kNm = (r.M_B / 1000).toFixed(2);
        html += `<tr><td>${r.span}</td><td>${length_m}</td><td>${M_A_kNm}</td><td>${M_B_kNm}</td></tr>`;
      });
      html += `</tbody></table>`;
    
      const steelCheckArea = document.getElementById('steelCheckArea');
      if (steelCheckArea) {
        // Remove any previous FEM table
        let oldFEM = document.getElementById('femResultsTable');
        if (oldFEM) oldFEM.remove();
        // Create a wrapper div for FEM results
        const femDiv = document.createElement('div');
        femDiv.id = 'femResultsTable';
        femDiv.innerHTML = html;
        // Insert FEM table just before the diagrams (i.e., before #beamDiagrams)
        const diagramsDiv = document.getElementById('beamDiagrams');
        if (diagramsDiv) {
          steelCheckArea.insertBefore(femDiv, diagramsDiv);
        } else {
          steelCheckArea.appendChild(femDiv);
        }
      }
    }

    const MomentDistribution = {
      buildMemberRow(nSpans) {
        let memberRow = '<tr><th>Member</th>';
          for (let j = 0; j <= nSpans; j++) {
            // L sub-column
            if (j > 0) {
              memberRow += `<td>${String.fromCharCode(65 + j) + String.fromCharCode(65 + j - 1)}</td>`;
            } else {
              memberRow += `<td></td>`;
            }
            // C sub-column (column at joint)
            memberRow += `<td>Col</td>`;
            // R sub-column
            if (j < nSpans) {
              memberRow += `<td>${String.fromCharCode(65 + j) + String.fromCharCode(65 + j + 1)}</td>`;
            } else {
              memberRow += `<td></td>`;
            }
          }
          memberRow += '</tr>';
          return memberRow;
        },
      
        getSpans() {
          let spans = [];
          // Span 1
          const span1Length = parseFloat(document.getElementById('spanLength').value) || 1000;
          let span1Loads = [];
          const span1LoadType = document.querySelector('input[name="loadType"]:checked').value;
          const span1LoadMag = parseFloat(document.getElementById('UltimateLoad').value) || 0;
          const span1LoadPos = parseFloat(document.getElementById('loadPosition')?.value) || 0;
          if (span1LoadMag > 0) {
            if (span1LoadType === "udl") {
              const udlFrom = parseFloat(document.getElementById('udlFrom')?.value) || 0;
              const udlTo = parseFloat(document.getElementById('udlTo')?.value) || span1Length;
              span1Loads.push({ type: "udl", mag: span1LoadMag, from: udlFrom, to: udlTo });
            } else {
              span1Loads.push({ type: span1LoadType, mag: span1LoadMag, pos: span1LoadPos });
            }
          }
          const span1LoadsContainer = document.querySelector('details .loadsContainer');
          if (span1LoadsContainer && span1LoadsContainer.children.length > 0) {
            Array.from(span1LoadsContainer.children).forEach(loadDiv => {
              const type = loadDiv.querySelector('input[type="radio"]:checked')?.value;
              let mag = 0, pos = 0;
              loadDiv.querySelectorAll('label').forEach(label => {
                if (label.textContent.trim().startsWith('Load Magnitude')) {
                  mag = parseFloat(label.querySelector('input').value) || 0;
                }
                if (label.textContent.trim().startsWith('Load Position')) {
                  pos = parseFloat(label.querySelector('input').value) || 0;
                }
              });
              if (type && mag > 0) {
                span1Loads.push({ type, mag, pos });
              }
            });
          }
          spans.push({ length: span1Length, loads: span1Loads });
        
          // Dynamic spans
          document.querySelectorAll('#spansContainer > details').forEach(details => {
            const spanDiv = details.querySelector('.span-fields');
            const length = parseFloat(spanDiv.querySelector('label input[type="number"]').value) || 1000;
            let loads = [];
            const mainType = spanDiv.querySelector('input[type="radio"]:checked').value;
            let mainMag = 0, mainPos = 0;
            spanDiv.querySelectorAll('label').forEach(label => {
              if (label.textContent.trim().startsWith('Load Magnitude')) {
                mainMag = parseFloat(label.querySelector('input').value) || 0;
              }
              if (label.textContent.trim().startsWith('Load Position')) {
                mainPos = parseFloat(label.querySelector('input').value) || 0;
              }
            });
            if (mainMag > 0) {
              loads.push({ type: mainType, mag: mainMag, pos: mainPos });
            }
            const loadsContainer = spanDiv.querySelector('.loadsContainer');
            if (loadsContainer && loadsContainer.children.length > 0) {
              Array.from(loadsContainer.children).forEach(loadDiv => {
                const type = loadDiv.querySelector('input[type="radio"]:checked')?.value;
                let mag = 0, pos = 0;
                loadDiv.querySelectorAll('label').forEach(label => {
                  if (label.textContent.trim().startsWith('Load Magnitude')) {
                    mag = parseFloat(label.querySelector('input').value) || 0;
                  }
                  if (label.textContent.trim().startsWith('Load Position')) {
                    pos = parseFloat(label.querySelector('input').value) || 0;
                  }
                });
                if (type && mag > 0) {
                  loads.push({ type, mag, pos });
                }
              });
            }
            spans.push({ length, loads });
          });
        
          return spans;
        },
      
        getColProps() {
          const E = parseFloat(document.getElementById('modulusE').value) * 1e9; // GPa to Pa
          const colWidth = parseFloat(document.getElementById('colWidth').value) / 1000; // mm to m
          const colBreadth = parseFloat(document.getElementById('colBreadth').value) / 1000; // mm to m
          const I_col = (colWidth * Math.pow(colBreadth, 3)) / 12;
          const H = parseFloat(document.getElementById('colHeight').value) / 1000; // mm to m
      
          // Beam I (use first span's width/depth)
          const beamWidth = parseFloat(document.getElementById('beamWidth').value) / 1000;
          const beamDepth = parseFloat(document.getElementById('beamDepth').value) / 1000;
          const I_beam = (beamWidth * Math.pow(beamDepth, 3)) / 12;
      
          return { E, I_col, H, I_beam };
        },
      
        run(spans, colProps) {
          let html = `<h3>Moment Distribution Table</h3>
            <table border="1" cellpadding="4" style="border-collapse:collapse;">
              <thead>
                ${this.buildMemberRow(spans.length)}
                <tr><th>DF</th>`;
          // Calculate DFs
          const E = colProps.E;
          const I_col = colProps.I_col;
          const H = colProps.H;
          const EI_col = E * I_col;
          const nSpans = spans.length;
          const EI_beams = spans.map(span => E * colProps.I_beam);
          const L_beams = spans.map(span => span.length);
          const K_cols = Array(nSpans + 1).fill(3 * EI_col / H);
          const K_beams = L_beams.map((L, i) => 4 * EI_beams[i] / L);
          let DFs = [];
          for (let j = 0; j <= nSpans; j++) {
            let members = [];
            if (j > 0) members.push({ name: 'L', K: K_beams[j - 1] });
            members.push({ name: 'C', K: K_cols[j] });
            if (j < nSpans) members.push({ name: 'R', K: K_beams[j] });
            let sumK = members.reduce((sum, m) => sum + m.K, 0);
            let df = {};
            members.forEach(m => {
              df[m.name] = m.K / sumK;
            });
            DFs[j] = {
              left: df.L || 0,
              col: df.C || 0,
              right: df.R || 0
            };
            html += `<td>${j > 0 ? DFs[j].left.toFixed(2) : ''}</td>`;
            html += `<td>${DFs[j].col.toFixed(2)}</td>`;
            html += `<td>${j < nSpans ? DFs[j].right.toFixed(2) : ''}</td>`;
          }
          html += '</tr>';
        
          // FEM row
          html += '<tr><th>FEM</th>';
          for (let j = 0; j <= nSpans; j++) {
            if (j > 0) {
              // Left end of span j (BA)
              const spanIdx = j - 1;
              const span = spans[spanIdx];
              let fem = 0;
              if (span.loads && Array.isArray(span.loads)) {
                span.loads.forEach(load => {
                  const L = span.L / 1000; // mm to m
                  if (load.type.toLowerCase() === "udl") {
                    let w = load.mag;
                    let a = load.from !== undefined ? load.from / 1000 : 0;
                    let b = load.to !== undefined ? load.to / 1000 : L;
                    let l = b - a;
                    if (l === L && a === 0) {
                      fem += -w * Math.pow(L, 2) / 12;
                    } else {
                      fem += -(w * l) * (L - (l / 2) - a) / 12;
                    }
                  } else if (load.type.toLowerCase() === "point") {
                    let P = load.mag;
                    let a = load.pos / 1000 || 0;
                    let b = L - a;
                    fem += P * Math.pow(a, 2) * b / Math.pow(L, 2);
                  } else if (load.type.toLowerCase() === "moment") {
                    let M = load.mag;
                    let a = load.pos / 1000 || 0;
                    fem += M * (1 - a / L);
                  }
                });
              }
              html += `<td>${fem.toFixed(2)}</td>`;
            } else {
              html += `<td></td>`;
            }
            html += `<td>0.00</td>`;
            if (j < nSpans) {
              // Right end of span j (AB)
              const span = spans[j];
              let fem = 0;
              if (span.loads && Array.isArray(span.loads)) {
                span.loads.forEach(load => {
                  const L = span.L / 1000; // mm to m
                  if (load.type.toLowerCase() === "udl") {
                    let w = load.mag;
                    let a = load.from !== undefined ? load.from / 1000 : 0;
                    let b = load.to !== undefined ? load.to / 1000 : L;
                    let l = b - a;
                    if (l === L && a === 0) {
                      fem += w * Math.pow(L, 2) / 12;
                    } else {
                      fem += (w * l) * ((l / 2) + a) / 12;
                    }
                  } else if (load.type.toLowerCase() === "point") {
                    let P = load.mag;
                    let a = load.pos / 1000 || 0;
                    let b = L - a;
                    fem += -P * a * Math.pow(b, 2) / Math.pow(L, 2);
                  } else if (load.type.toLowerCase() === "moment") {
                    let M = load.mag;
                    let a = load.pos / 1000 || 0;
                    fem += M * (a / L);
                  }
                });
              }
              html += `<td>${fem.toFixed(2)}</td>`;
            } else {
              html += `<td></td>`;
            }
          }
          html += '</tr>';
          html += '</thead><tbody>';
        
          // --- Dynamic Moment Distribution Iterations ---
          let prevCOMs = [];
          let threshold = 0.01;
          let maxIters = 50;
          let iter = 1;
          
          // Initialize moments with FEMs
          let moments = [];
          for (let i = 0; i < nSpans; i++) {
            let leftFEM = 0, rightFEM = 0;
            const span = spans[i];
            if (span.loads && Array.isArray(span.loads)) {
              span.loads.forEach(load => {
                const L = span.L / 1000; // mm to m
                if (load.type.toLowerCase() === "udl") {
                  let w = load.mag;
                  let a = load.from !== undefined ? load.from / 1000 : 0;
                  let b = load.to !== undefined ? load.to / 1000 : L;
                  let l = b - a;
                  if (l === L && a === 0) {
                    leftFEM += -w * Math.pow(L, 2) / 12;
                    rightFEM += w * Math.pow(L, 2) / 12;
                  } else {
                    leftFEM += -(w * l) * (L - (l / 2) - a) / 12;
                    rightFEM += (w * l) * ((l / 2) + a) / 12;
                  }
                } else if (load.type.toLowerCase() === "point") {
                  let P = load.mag;
                  let a = load.pos / 1000 || 0;
                  let b = L - a;
                  leftFEM += -P * Math.pow(b, 2) * a / Math.pow(L, 2);
                  rightFEM += P * Math.pow(a, 2) * b / Math.pow(L, 2);
                } else if (load.type.toLowerCase() === "moment") {
                  let M = load.mag;
                  let a = load.pos / 1000 || 0;
                  leftFEM += M * (1 - a / L);
                  rightFEM += M * (a / L);
                }
              });
            }
            moments[i] = { left: leftFEM, right: rightFEM };
          }
          let colMoments = Array(nSpans + 1).fill(0);
          
          while (iter <= maxIters) {
            let balances = [];
            let maxBalance = 0;
            html += `<tr><th>Balance ${iter}</th>`;
            for (let j = 0; j <= nSpans; j++) {
              // Sum moments at joint: left (from previous span), right (from next span), and column
              let sumAtJoint = (moments[j - 1]?.right || 0) + (moments[j]?.left || 0) + (colMoments[j] || 0);
              let balL = j > 0 ? (-sumAtJoint * DFs[j].left) : '';
              let balC = -sumAtJoint * DFs[j].col;
              let balR = j < nSpans ? (-sumAtJoint * DFs[j].right) : '';
              balances[j] = { L: balL, C: balC, R: balR };
              [balL, balC, balR].forEach(val => {
                if (typeof val === "number") maxBalance = Math.max(maxBalance, Math.abs(val));
              });
              html += `<td>${balL !== '' ? Number(balL).toFixed(2) : ''}</td><td>${balC.toFixed(2)}</td><td>${balR !== '' ? Number(balR).toFixed(2) : ''}</td>`;
            }
            html += '</tr>';
          
            // --- COM Row ---
            html += `<tr><th>COM ${iter}</th>`;
            for (let j = 0; j <= nSpans; j++) {
              // Left member (BA)
              if (j > 0) {
                if (iter === 1) {
                  // Use Balance 1 for first COM
                  html += `<td>${(balances[j - 1].R / 2).toFixed(2)}</td>`;
                } else if (prevCOMs[j - 1]) {
                  html += `<td>${(prevCOMs[j - 1].R / 2).toFixed(2)}</td>`;
                } else {
                  html += `<td></td>`;
                }
              } else {
                html += `<td></td>`;
              }
              // Column
              html += `<td>0.00</td>`;
              // Right member (AB)
              if (j < nSpans) {
                if (iter === 1) {
                  html += `<td>${(balances[j + 1]?.L / 2).toFixed(2)}</td>`;
                } else if (prevCOMs[j + 1]) {
                  html += `<td>${(prevCOMs[j + 1].L / 2).toFixed(2)}</td>`;
                } else {
                  html += `<td></td>`;
                }
              } else {
                html += `<td></td>`;
              }
            }
            html += '</tr>';
          
            // --- Update moments with balances and COMs ---
            for (let j = 1; j < nSpans; j++) {
              let sumAtJoint = (moments[j - 1].right || 0) + (moments[j].left || 0) + (colMoments[j] || 0);
              let dist_left = -sumAtJoint * DFs[j].left;
              let dist_right = -sumAtJoint * DFs[j].right;
              let dist_col = -sumAtJoint * DFs[j].col;
              moments[j - 1].right += dist_left;
              moments[j].left += dist_right;
              colMoments[j] += dist_col;
              // Carry-over: add half of the distributed moment to the far end
              moments[j - 1].left += dist_left / 2;
              moments[j].right += dist_right / 2;
            }
            prevCOMs = balances;
            iter++;
            if (maxBalance < threshold) break;
          }
        
          // --- Total (final) moments row ---
          html += '<tr><th>Total</th>';
          for (let j = 0; j <= nSpans; j++) {
            if (j > 0) {
              html += `<td>${moments[j - 1].right.toFixed(2)}</td>`;
            } else {
              html += `<td></td>`;
            }
            html += `<td>${(colMoments[j] || 0).toFixed(2)}</td>`;
            if (j < nSpans) {
              html += `<td>${moments[j].left.toFixed(2)}</td>`;
            } else {
              html += `<td></td>`;
            }
          }

          window.mdSupportMoments = [];
          for (let i = 0; i < nSpans; i++) {
            window.mdSupportMoments.push({
              left: moments[i].left,   // Moment at left end of span i
              right: moments[i].right  // Moment at right end of span i
            });
          }
          html += '</tr>';
          html += '</tbody></table>';
        
          // Remove any previous table in the result area
          let femDiv = document.getElementById('femResultsTable');
          let mdOld = document.getElementById('momentDistributionTable');
          if (mdOld) mdOld.remove();
          // Create a new div for the moment distribution table
          const mdDiv = document.createElement('div');
          mdDiv.id = 'momentDistributionTable';
          mdDiv.innerHTML = html; // html contains <table>...</table>
          const steelCheckArea = document.getElementById('steelCheckArea');
          // Insert just after the FEM table
          if (femDiv && femDiv.parentNode) {
            femDiv.parentNode.insertBefore(mdDiv, femDiv.nextSibling);
          } else if (steelCheckArea) {
            steelCheckArea.appendChild(mdDiv);
          }
        },
      
        updateTable() {
          const spans = this.getSpans();
          const colProps = this.getColProps();
          this.run(spans, colProps);
        }
    };

    function downloadPDF() {
      showFEMResults();
      MomentDistribution.updateTable();

      const { jsPDF } = window.jspdf;
      const doc = new jsPDF();
    
      // Set a clean font
      doc.setFont("helvetica", "normal");
    
      // Title
      doc.setFontSize(20);
      doc.setTextColor(40, 40, 40);
      doc.text("Beam Calculation Report", 10, 18);
    
      // Section separator
      doc.setDrawColor(220, 220, 220);
      doc.setLineWidth(0.8);
      doc.line(10, 22, 200, 22);
    
      // Metadata
      doc.setFontSize(10);
      doc.setTextColor(120, 120, 120);
      doc.text("Job Number: ____________________", 10, 28);
      doc.text("Client: _________________________", 10, 33);
      doc.text("Calculated by: __________________", 10, 38);
      doc.text("Date: " + new Date().toLocaleDateString(), 150, 28);
    
      // Section: Input Parameters
      let y = 45;
      doc.setFontSize(13);
      doc.setTextColor(60, 60, 60);
      doc.setFont(undefined, "bold");
      doc.text("Input Parameters", 10, y);
      doc.setFont(undefined, "normal");
      doc.setFontSize(11);
      doc.setTextColor(60, 60, 60);
    
      // Draw a light gray box for input parameters
      doc.setFillColor(245, 247, 250);
      doc.rect(10, y + 3, 190, 9 * 8, "F");
    
      const inputParams = [
        `Support Condition: ${document.getElementById("supportCondition").value}`,
        `Beam Type: ${document.getElementById("beamType").value}`,
        `Beam Depth (h): ${document.getElementById("beamDepth").value} mm`,
        `Beam Width (b): ${document.getElementById("beamWidth").value} mm`,
        `Flange Depth (hf): ${document.getElementById("flangeDepth").value} mm`,
        `Concrete Cover: ${document.getElementById("concreteCover").value} mm`,
        `Diameter of Bar: ${document.getElementById("barDiameter").value} mm`,
        `Diameter of Link: ${document.getElementById("linkDiameter").value} mm`,
        `fck: ${document.getElementById("fck").value} N/mm²`,
        `fyk: ${document.getElementById("fyk").value} N/mm²`,
      ];
      inputParams.forEach((param, idx) => {
        doc.text(param, 14, y + 10 + idx * 8);
      });
    
      y += 10 + inputParams.length * 8;
    
      // Section: Results
      doc.setFontSize(13);
      doc.setFont(undefined, "bold");
      doc.setTextColor(60, 60, 60);
      doc.text("Results", 10, y + 8);
      doc.setFont(undefined, "normal");
      doc.setFontSize(11);
      doc.setTextColor(60, 60, 60);
    
      // Section separator
      doc.setDrawColor(220, 220, 220);
      doc.setLineWidth(0.5);
      doc.line(10, y + 10, 200, y + 10);
    
      // Main results (fullResult)
      let content = fullResult;
      content = content.replace(/<br\s*\/?>/gi, "\n").replace(/<[^>]+>/g, "");
      let resultLines = doc.splitTextToSize(content, 180);
      let resultY = y + 18;
      resultLines.forEach(line => {
        if (resultY > 280) { doc.addPage(); resultY = 20; }
        doc.text(line, 10, resultY);
        resultY += 8;
      });
      y = resultY;
    
      // Provided area of steel and checks (from steelCheckArea)
      const steelCheckArea = document.getElementById("steelCheckArea");
      if (steelCheckArea) {
        // Clone steelCheckArea and remove the tables before extracting text
        let clone = steelCheckArea.cloneNode(true);
        let femTable = clone.querySelector('#femResultsTable');
        if (femTable) femTable.remove();
        let mdTable = clone.querySelector('#momentDistributionTable');
        if (mdTable) mdTable.remove();
        let steelText = clone.innerText || clone.textContent || "";
        if (steelText.trim()) {
          if (y > 230) { doc.addPage(); y = 20; }
          doc.setFontSize(14);
          doc.text("Steel Checks & Provided Area", 10, y + 10);
          doc.setFontSize(12);
          // Format steel checks for better line breaks
          let steelLines = steelText.replace(/\s{2,}/g, ' ').split(/\n|\. |\r/).map(s => s.trim()).filter(Boolean);
          let formattedSteelLines = [];
          steelLines.forEach(line => {
            if (line.length > 90) {
              formattedSteelLines.push(...doc.splitTextToSize(line, 180));
            } else {
              formattedSteelLines.push(line);
            }
          });
          doc.text(formattedSteelLines, 10, y + 18);
          y += 18 + formattedSteelLines.length * 8;
        }
      }
    
      // FEM Table with jsPDF-AutoTable
      const femDiv = document.getElementById('femResultsTable');
      if (femDiv) {
        const table = femDiv.querySelector('table');
        if (table) {
          // Get headers
          const headers = [];
          table.querySelectorAll('thead tr th').forEach(th => {
            headers.push(th.textContent.trim());
          });
          // Get rows
          const rows = [];
          table.querySelectorAll('tbody tr').forEach(tr => {
            const row = [];
            tr.querySelectorAll('td').forEach(td => {
              row.push(td.textContent.trim());
            });
            if (row.length) rows.push(row);
          });
    
          if (y > 230) { doc.addPage(); y = 20; }
          doc.setFontSize(14);
          doc.text("Fixed-End Moments (FEM) Table", 10, y + 10);
          doc.setFontSize(11);
    
          doc.autoTable({
            head: [headers],
            body: rows,
            startY: y + 18,
            theme: 'grid',
            styles: {
              font: 'helvetica',
              fontSize: 11,
              cellPadding: 3,
              textColor: [45,58,74],
              lineColor: [220,220,220]
            },
            headStyles: {
              fillColor: [230,233,242],
              textColor: [45,58,74],
              fontStyle: 'bold'
            },
            alternateRowStyles: { fillColor: [244,247,250] },
            tableLineColor: [220,220,220],
            tableLineWidth: 0.5,
          });
          y = doc.lastAutoTable.finalY + 10;
        }
      }
    
      // Moment Distribution Table with jsPDF-AutoTable
      const mdDiv = document.getElementById('momentDistributionTable');
      if (mdDiv) {
        const table = mdDiv.querySelector('table');
        if (table) {
          // Get all header rows
          const headRows = [];
          table.querySelectorAll('thead tr').forEach(tr => {
            const row = [];
            tr.querySelectorAll('th').forEach(th => {
              row.push(th.textContent.trim());
            });
            if (row.length) headRows.push(row);
          });
          // Get all body rows (only <td> cells, skip <th>)
          const bodyRows = [];
          table.querySelectorAll('tbody tr').forEach(tr => {
            const row = [];
            tr.querySelectorAll('td').forEach(td => {
              row.push(td.textContent.trim());
            });
            if (row.length) bodyRows.push(row);
          });
      
          if (y > 230) { doc.addPage(); y = 20; }
          doc.setFontSize(14);
          doc.text("Moment Distribution Table", 10, y + 10);
          doc.setFontSize(10);
      
          doc.autoTable({
            head: headRows,
            body: bodyRows,
            startY: y + 18,
            theme: 'grid',
            styles: {
              font: 'helvetica',
              fontSize: 9,
              cellPadding: 2,
              textColor: [45,58,74],
              lineColor: [220,220,220]
            },
            headStyles: {
              fillColor: [230,233,242],
              textColor: [45,58,74],
              fontStyle: 'bold'
            },
            alternateRowStyles: { fillColor: [244,247,250] },
            tableLineColor: [220,220,220],
            tableLineWidth: 0.5,
          });
          y = doc.lastAutoTable.finalY + 10;
        }
      }
    
      // FBD, SFD, BMD diagrams (no titles)
      function addDiagram(canvasId) {
        const canvas = document.getElementById(canvasId);
        if (canvas) {
          if (y > 200) { doc.addPage(); y = 20; }
          const imgData = canvas.toDataURL('image/png');
          doc.addImage(imgData, 'PNG', 10, y + 10, 180, 60);
          y += 70;
        }
      }
      addDiagram('resultFBDCanvas');
      addDiagram('resultSFDCanvas');
      addDiagram('resultBMDCanvas');
    
      // Save the PDF
      doc.save("Beam_Calculation_Report.pdf");
    }

    //---Miscellaneous---
    // Add event listeners for "+ Add Load" on Span 1, etc.
    document.querySelector('.addLoadBtn').addEventListener('click', function(e) {
      e.preventDefault();
      const details = document.querySelector('details');
      const loadsContainer = details.querySelector('.loadsContainer');
      addDynamicLoad(loadsContainer, 1, details);
    });

    //---Load Position UI---
    function updateLoadPositionUI() {
      const spanLength = parseFloat(document.getElementById('spanLength').value) || 1000;
      const loadType = document.querySelector('input[name="loadType"]:checked').value;
      const container = document.getElementById('loadPositionContainer');
      if (loadType === "udl") {
        container.innerHTML = `
          <label id="loadPositionLabel" style="display: flex; justify-content: space-between; align-items: center; width: 320px;">
            Where is it acting (mm): 
            <span style="display:flex;gap:5px;align-items:center;">
              from <input type="number" id="udlFrom" value="0" min="0" max="${spanLength}" style="width:70px;">
              to <input type="number" id="udlTo" value="${spanLength}" min="0" max="${spanLength}" style="width:70px;">
            </span>
          </label>
        `;
        // Safeguard: keep values within span
        const fromInput = document.getElementById('udlFrom');
        const toInput = document.getElementById('udlTo');
        fromInput.addEventListener('input', () => {
          if (parseFloat(fromInput.value) < 0) fromInput.value = 0;
          if (parseFloat(fromInput.value) > spanLength) fromInput.value = spanLength;
          if (parseFloat(fromInput.value) > parseFloat(toInput.value)) fromInput.value = toInput.value;
          drawFBDAllSpans();
        });
        toInput.addEventListener('input', () => {
          if (parseFloat(toInput.value) < 0) toInput.value = 0;
          if (parseFloat(toInput.value) > spanLength) toInput.value = spanLength;
          if (parseFloat(toInput.value) < parseFloat(fromInput.value)) toInput.value = fromInput.value;
          drawFBDAllSpans();
        });
      } else {
        container.innerHTML = `
          <label id="loadPositionLabel" style="display: flex; justify-content: space-between; align-items: center; width: 320px;">
            Load Position (mm, for point/moment): <input type="number" id="loadPosition" value="2" style="width: 55%;">
          </label>
        `;
        document.getElementById('loadPosition').addEventListener('input', drawFBDAllSpans);
      }
    }
    document.querySelectorAll('input[name="loadType"]').forEach(radio => {
      radio.addEventListener('change', updateLoadPositionUI);
    });
    document.getElementById('spanLength').addEventListener('input', updateLoadPositionUI);
    
    // Call once on page load
    window.addEventListener('DOMContentLoaded', function() {
      updateLoadPositionUI();
      drawFBDAllSpans();
    });
    
    // Update FBD on any input or change
    ['input', 'change'].forEach(evt =>
      document.addEventListener(evt, drawFBDAllSpans)
    );

    // Show/hide spans section based on support condition
    document.getElementById('supportCondition').addEventListener('change', function() {
      const val = this.value;
      document.getElementById('spansContainer').style.display = (val === 'continuous') ? '' : 'none';
      document.getElementById('addSpanBtn').style.display = (val === 'continuous') ? '' : 'none';
      document.getElementById('beamDiagrams').style.display = (val === 'simply') ? '' : 'none';
    });
  </script>
</body>
</html>
